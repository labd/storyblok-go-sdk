// Package sbmgmt provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package sbmgmt

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Component defines model for Component.
type Component struct {
	// AllPresets An array of presets associated with the component
	AllPresets *[]interface{} `json:"all_presets,omitempty"`

	// ComponentGroupUuid The component group uuid of the component
	ComponentGroupUuid *string `json:"component_group_uuid,omitempty"`

	// CreatedAt The creation timestamp of the component
	CreatedAt time.Time `json:"created_at"`

	// DisplayName The display name of the component
	DisplayName *string `json:"display_name,omitempty"`

	// Id The ID of the component
	Id int64 `json:"id"`

	// Image URL to the preview image, if uploaded
	Image *string `json:"image,omitempty"`

	// IsNestable Component should be insertable in blocks field type fields
	IsNestable *bool `json:"is_nestable,omitempty"`

	// IsRoot Component should be usable as a Content Type
	IsRoot *bool `json:"is_root,omitempty"`

	// Name Technical name used for component property in entries
	Name string `json:"name"`

	// PresetId The ID of the preset associated with the component (null if not set)
	PresetId *string `json:"preset_id,omitempty"`

	// Preview Define the field that should be used for preview in the interface
	Preview *string `json:"preview,omitempty"`

	// RealName The real name of the component
	RealName *string `json:"real_name,omitempty"`

	// Schema The definition of fields (schema) for this component
	Schema *map[string]FieldInput `json:"schema,omitempty"`
}

// ComponentGroup defines model for ComponentGroup.
type ComponentGroup struct {
	// Id The ID of the component group
	Id *int `json:"id,omitempty"`

	// Name The name of the component group
	Name *string `json:"name,omitempty"`

	// Uuid The UUID of the component group
	Uuid *string `json:"uuid,omitempty"`
}

// ComponentInput ComponentInput
type ComponentInput struct {
	// ComponentGroupUuid The component group uuid of the component
	ComponentGroupUuid *string `json:"component_group_uuid,omitempty"`

	// DisplayName The display name of the component
	DisplayName *string `json:"display_name,omitempty"`

	// Image URL to the preview image, if uploaded
	Image *string `json:"image,omitempty"`

	// IsNestable Component should be insertable in blocks field type fields
	IsNestable *bool `json:"is_nestable,omitempty"`

	// IsRoot Component should be usable as a Content Type
	IsRoot *bool `json:"is_root,omitempty"`

	// Name Technical name used for component property in entries
	Name string `json:"name"`

	// Preview Define the field that should be used for preview in the interface
	Preview *string `json:"preview,omitempty"`

	// Schema The definition of fields (schema) for this component
	Schema *map[string]FieldInput `json:"schema,omitempty"`
}

// Field defines model for Field.
type Field struct {
	// AddHttps Prepends https: to stop usage of relative protocol
	AddHttps *bool `json:"add_https,omitempty"`

	// AssetFolderId Default asset folder numeric id to store uploaded image of that field
	AssetFolderId *int `json:"asset_folder_id,omitempty"`

	// CanSync Advanced usage to sync with field in preview; Default: false
	CanSync *bool `json:"can_sync,omitempty"`

	// ComponentWhitelist Array of component/content type names: ["post","page","product"]
	ComponentWhitelist *[]string `json:"component_whitelist,omitempty"`

	// DatasourceSlug Define selectable datasources string; Effects editor only if source=internal
	DatasourceSlug *string `json:"datasource_slug,omitempty"`

	// DefaultValue Default value for the field; Can be an escaped JSON object
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description shown in the editor interface
	Description *string `json:"description,omitempty"`

	// DisableTime Disables time selection from date picker; Default: false
	DisableTime *bool `json:"disable_time,omitempty"`

	// ExternalDatasource Define external datasource JSON Url; Effects editor only if source=external
	ExternalDatasource *string `json:"external_datasource,omitempty"`

	// FieldType Name of the custom field type plugin
	FieldType *string `json:"field_type,omitempty"`

	// Filetypes Array of file type names: ["images", "videos", "audios", "texts"]
	Filetypes *[]string `json:"filetypes,omitempty"`

	// FolderSlug Filter on selectable stories path; Effects editor only if source=internal_stories; In case you have a multi-language folder structure you can add the '{0}' placeholder and the path will be adapted dynamically. Examples: "{0}/categories/", {0}/{1}/categories/
	FolderSlug *string `json:"folder_slug,omitempty"`

	// Id Numeric Unique ID
	Id *int64 `json:"id,omitempty"`

	// ImageCrop Activate force crop for images: (true/false)
	ImageCrop *bool `json:"image_crop,omitempty"`

	// ImageHeight Define height in px or height ratio if keep_image_size is enabled
	ImageHeight *string `json:"image_height,omitempty"`

	// ImageWidth Define width in px or width ratio if keep_image_size is enabled
	ImageWidth *string `json:"image_width,omitempty"`

	// KeepImageSize Keep original size: (true/false)
	KeepImageSize *bool `json:"keep_image_size,omitempty"`

	// Keys Array of field keys to include in this section
	Keys *[]string `json:"keys,omitempty"`

	// MaxLength Set the max length of the input string
	MaxLength *int `json:"max_length,omitempty"`

	// Maximum Maximum amount of added bloks in this blok field
	Maximum *int `json:"maximum,omitempty"`

	// NoTranslate Should be excluded in translation export
	NoTranslate *bool `json:"no_translate,omitempty"`

	// Options Array of datasource entries [{name:"", value:""}]; Effects editor only if source=undefined
	Options *[]struct {
		Name  *string `json:"name,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"options,omitempty"`

	// Pos The position of the field
	Pos int64 `json:"pos"`

	// PreviewField Is used as instance preview field below component name in bloks types
	PreviewField *bool `json:"preview_field,omitempty"`

	// Regex Client Regex validation for the field
	Regex *string `json:"regex,omitempty"`

	// Required Is field required; Default: false
	Required *bool `json:"required,omitempty"`

	// RestrictComponents Activate restriction nestable component option; Default: false
	RestrictComponents *bool `json:"restrict_components,omitempty"`

	// RestrictContentTypes Activate restriction content type option
	RestrictContentTypes *bool `json:"restrict_content_types,omitempty"`

	// RichMarkdown Enable rich markdown view by default (true/false)
	RichMarkdown *bool `json:"rich_markdown,omitempty"`

	// Rtl Enable global RTL for this field
	Rtl *bool `json:"rtl,omitempty"`

	// Source Possible values: undefined: Self; internal_stories: Stories; internal: Datasource; external: API Endpoint in Datasource Entries Array Format
	Source *string `json:"source,omitempty"`

	// Translatable Can field be translated; Default: false
	Translatable *bool `json:"translatable,omitempty"`

	// Type The type of the field
	Type string `json:"type"`

	// UseUuid Default: true; available in option and source=internal_stories
	UseUuid *bool `json:"use_uuid,omitempty"`
}

// FieldInput defines model for FieldInput.
type FieldInput struct {
	// AddHttps Prepends https: to stop usage of relative protocol
	AddHttps *bool `json:"add_https,omitempty"`

	// AssetFolderId Default asset folder numeric id to store uploaded image of that field
	AssetFolderId *int `json:"asset_folder_id,omitempty"`

	// CanSync Advanced usage to sync with field in preview; Default: false
	CanSync *bool `json:"can_sync,omitempty"`

	// ComponentWhitelist Array of component/content type names: ["post","page","product"]
	ComponentWhitelist *[]string `json:"component_whitelist,omitempty"`

	// DatasourceSlug Define selectable datasources string; Effects editor only if source=internal
	DatasourceSlug *string `json:"datasource_slug,omitempty"`

	// DefaultValue Default value for the field; Can be an escaped JSON object
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description shown in the editor interface
	Description *string `json:"description,omitempty"`

	// DisableTime Disables time selection from date picker; Default: false
	DisableTime *bool `json:"disable_time,omitempty"`

	// ExternalDatasource Define external datasource JSON Url; Effects editor only if source=external
	ExternalDatasource *string `json:"external_datasource,omitempty"`

	// FieldType Name of the custom field type plugin
	FieldType *string `json:"field_type,omitempty"`

	// Filetypes Array of file type names: ["images", "videos", "audios", "texts"]
	Filetypes *[]string `json:"filetypes,omitempty"`

	// FolderSlug Filter on selectable stories path; Effects editor only if source=internal_stories; In case you have a multi-language folder structure you can add the '{0}' placeholder and the path will be adapted dynamically. Examples: "{0}/categories/", {0}/{1}/categories/
	FolderSlug *string `json:"folder_slug,omitempty"`

	// ImageCrop Activate force crop for images: (true/false)
	ImageCrop *bool `json:"image_crop,omitempty"`

	// ImageHeight Define height in px or height ratio if keep_image_size is enabled
	ImageHeight *string `json:"image_height,omitempty"`

	// ImageWidth Define width in px or width ratio if keep_image_size is enabled
	ImageWidth *string `json:"image_width,omitempty"`

	// KeepImageSize Keep original size: (true/false)
	KeepImageSize *bool `json:"keep_image_size,omitempty"`

	// Keys Array of field keys to include in this section
	Keys *[]string `json:"keys,omitempty"`

	// MaxLength Set the max length of the input string
	MaxLength *int `json:"max_length,omitempty"`

	// Maximum Maximum amount of added bloks in this blok field
	Maximum *int `json:"maximum,omitempty"`

	// NoTranslate Should be excluded in translation export
	NoTranslate *bool `json:"no_translate,omitempty"`

	// Options Array of datasource entries [{name:"", value:""}]; Effects editor only if source=undefined
	Options *[]struct {
		Name  *string `json:"name,omitempty"`
		Value *string `json:"value,omitempty"`
	} `json:"options,omitempty"`

	// Pos The position of the field
	Pos int64 `json:"pos"`

	// PreviewField Is used as instance preview field below component name in bloks types
	PreviewField *bool `json:"preview_field,omitempty"`

	// Regex Client Regex validation for the field
	Regex *string `json:"regex,omitempty"`

	// Required Is field required; Default: false
	Required *bool `json:"required,omitempty"`

	// RestrictComponents Activate restriction nestable component option; Default: false
	RestrictComponents *bool `json:"restrict_components,omitempty"`

	// RestrictContentTypes Activate restriction content type option
	RestrictContentTypes *bool `json:"restrict_content_types,omitempty"`

	// RichMarkdown Enable rich markdown view by default (true/false)
	RichMarkdown *bool `json:"rich_markdown,omitempty"`

	// Rtl Enable global RTL for this field
	Rtl *bool `json:"rtl,omitempty"`

	// Source Possible values: undefined: Self; internal_stories: Stories; internal: Datasource; external: API Endpoint in Datasource Entries Array Format
	Source *string `json:"source,omitempty"`

	// Translatable Can field be translated; Default: false
	Translatable *bool `json:"translatable,omitempty"`

	// Type The type of the field
	Type string `json:"type"`

	// UseUuid Default: true; available in option and source=internal_stories
	UseUuid *bool `json:"use_uuid,omitempty"`
}

// Space defines model for Space.
type Space struct {
	// ApiLogsPerMonth An array of API logs per month
	ApiLogsPerMonth *[]interface{} `json:"api_logs_per_month,omitempty"`

	// ApiRequests The total number of API requests allowed
	ApiRequests *int `json:"api_requests,omitempty"`

	// AssetsCount The count of assets in the space
	AssetsCount *int `json:"assets_count,omitempty"`

	// BillingAddress The billing address of the space
	BillingAddress *map[string]interface{} `json:"billing_address,omitempty"`

	// Collaborators An array of collaborators
	Collaborators *[]interface{} `json:"collaborators,omitempty"`

	// CreatedAt The creation timestamp of the space
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// DefaultRoot The default root of the space
	DefaultRoot *string `json:"default_root,omitempty"`

	// Domain The domain of the space
	Domain *string `json:"domain,omitempty"`

	// Duplicatable Indicates whether the space is duplicatable (null if not set)
	Duplicatable *string `json:"duplicatable,omitempty"`

	// Environments The environments of the space (null if not set)
	Environments *string `json:"environments,omitempty"`

	// Euid The EUID of the space (null if not set)
	Euid *string `json:"euid,omitempty"`

	// ExceededRequests The count of exceeded API requests
	ExceededRequests *int `json:"exceeded_requests,omitempty"`

	// FirstToken The first token of the space
	FirstToken *string `json:"first_token,omitempty"`

	// HasPendingTasks Indicates whether the space has pending tasks
	HasPendingTasks *bool `json:"has_pending_tasks,omitempty"`

	// HasSlackWebhook Indicates whether the space has a Slack webhook
	HasSlackWebhook *bool `json:"has_slack_webhook,omitempty"`

	// Id The ID of the space
	Id *int64 `json:"id,omitempty"`

	// Limits The limits of the space
	Limits *map[string]interface{} `json:"limits,omitempty"`

	// Name The name of the space
	Name *string `json:"name,omitempty"`

	// Options The options of the space
	Options *map[string]interface{} `json:"options,omitempty"`

	// Owner The owner of the space
	Owner *map[string]interface{} `json:"owner,omitempty"`

	// OwnerId The ID of the owner of the space
	OwnerId *int `json:"owner_id,omitempty"`

	// ParentId The ID of the parent space (null if not set)
	ParentId *string `json:"parent_id,omitempty"`

	// Plan The plan of the space
	Plan *string `json:"plan,omitempty"`

	// PlanLevel The plan level of the space
	PlanLevel *int `json:"plan_level,omitempty"`

	// RequestCountToday The count of requests made today
	RequestCountToday *int `json:"request_count_today,omitempty"`

	// Role The role of the user in the space
	Role *string `json:"role,omitempty"`

	// Routes An array of routes
	Routes *[]interface{} `json:"routes,omitempty"`

	// SearchblokId The Searchblok ID of the space (null if not set)
	SearchblokId *string `json:"searchblok_id,omitempty"`

	// Settings An array of settings
	Settings *[]interface{} `json:"settings,omitempty"`

	// StoriesCount The count of stories in the space
	StoriesCount *int `json:"stories_count,omitempty"`

	// StoryPublishedHook The story published hook of the space (null if not set)
	StoryPublishedHook *string `json:"story_published_hook,omitempty"`

	// Trial Indicates whether the space is in trial mode
	Trial *bool `json:"trial,omitempty"`

	// UniqDomain The unique domain of the space (null if not set)
	UniqDomain *string `json:"uniq_domain,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Events    *[]string  `json:"events,omitempty"`
	Id        *string    `json:"id,omitempty"`
	Name      *string    `json:"name,omitempty"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
	Url       *string    `json:"url,omitempty"`
}

// SpaceIdParam defines model for spaceIdParam.
type SpaceIdParam = int64

// GetSpacesSpaceIdWebhooksParams defines parameters for GetSpacesSpaceIdWebhooks.
type GetSpacesSpaceIdWebhooksParams struct {
	// Token The API access token
	Token string `form:"token" json:"token"`
}

// GetSpacesSpaceIdWebhooksWebhookIdParams defines parameters for GetSpacesSpaceIdWebhooksWebhookId.
type GetSpacesSpaceIdWebhooksWebhookIdParams struct {
	// Token The API access token
	Token string `form:"token" json:"token"`
}

// CreateComponentJSONRequestBody defines body for CreateComponent for application/json ContentType.
type CreateComponentJSONRequestBody = ComponentInput

// UpdateComponentJSONRequestBody defines body for UpdateComponent for application/json ContentType.
type UpdateComponentJSONRequestBody = ComponentInput

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetSpacesSpaceIdComponentGroupsGroupId request
	GetSpacesSpaceIdComponentGroupsGroupId(ctx context.Context, spaceId int, groupId int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpacesSpaceIdWebhooks request
	GetSpacesSpaceIdWebhooks(ctx context.Context, spaceId string, params *GetSpacesSpaceIdWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpacesSpaceIdWebhooksWebhookId request
	GetSpacesSpaceIdWebhooksWebhookId(ctx context.Context, spaceId string, webhookId string, params *GetSpacesSpaceIdWebhooksWebhookIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpace request
	GetSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComponent request with any body
	CreateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComponent(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComponent request
	DeleteComponent(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComponent request
	GetComponent(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComponent request with any body
	UpdateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComponent(ctx context.Context, spaceId SpaceIdParam, id int64, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetSpacesSpaceIdComponentGroupsGroupId(ctx context.Context, spaceId int, groupId int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacesSpaceIdComponentGroupsGroupIdRequest(c.Server, spaceId, groupId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpacesSpaceIdWebhooks(ctx context.Context, spaceId string, params *GetSpacesSpaceIdWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacesSpaceIdWebhooksRequest(c.Server, spaceId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpacesSpaceIdWebhooksWebhookId(ctx context.Context, spaceId string, webhookId string, params *GetSpacesSpaceIdWebhooksWebhookIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpacesSpaceIdWebhooksWebhookIdRequest(c.Server, spaceId, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComponentRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComponent(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComponentRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComponent(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComponentRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComponent(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComponentRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponent(ctx context.Context, spaceId SpaceIdParam, id int64, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetSpacesSpaceIdComponentGroupsGroupIdRequest generates requests for GetSpacesSpaceIdComponentGroupsGroupId
func NewGetSpacesSpaceIdComponentGroupsGroupIdRequest(server string, spaceId int, groupId int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "group_id", runtime.ParamLocationPath, groupId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/component-groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpacesSpaceIdWebhooksRequest generates requests for GetSpacesSpaceIdWebhooks
func NewGetSpacesSpaceIdWebhooksRequest(server string, spaceId string, params *GetSpacesSpaceIdWebhooksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/webhooks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpacesSpaceIdWebhooksWebhookIdRequest generates requests for GetSpacesSpaceIdWebhooksWebhookId
func NewGetSpacesSpaceIdWebhooksWebhookIdRequest(server string, spaceId string, webhookId string, params *GetSpacesSpaceIdWebhooksWebhookIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhook_id", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/webhooks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceRequest generates requests for GetSpace
func NewGetSpaceRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComponentRequest calls the generic CreateComponent builder with application/json body
func NewCreateComponentRequest(server string, spaceId SpaceIdParam, body CreateComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateComponentRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateComponentRequestWithBody generates requests for CreateComponent with any type of body
func NewCreateComponentRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComponentRequest generates requests for DeleteComponent
func NewDeleteComponentRequest(server string, spaceId SpaceIdParam, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComponentRequest generates requests for GetComponent
func NewGetComponentRequest(server string, spaceId SpaceIdParam, id int64) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateComponentRequest calls the generic UpdateComponent builder with application/json body
func NewUpdateComponentRequest(server string, spaceId SpaceIdParam, id int64, body UpdateComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateComponentRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateComponentRequestWithBody generates requests for UpdateComponent with any type of body
func NewUpdateComponentRequestWithBody(server string, spaceId SpaceIdParam, id int64, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetSpacesSpaceIdComponentGroupsGroupId request
	GetSpacesSpaceIdComponentGroupsGroupIdWithResponse(ctx context.Context, spaceId int, groupId int, reqEditors ...RequestEditorFn) (*GetSpacesSpaceIdComponentGroupsGroupIdResponse, error)

	// GetSpacesSpaceIdWebhooks request
	GetSpacesSpaceIdWebhooksWithResponse(ctx context.Context, spaceId string, params *GetSpacesSpaceIdWebhooksParams, reqEditors ...RequestEditorFn) (*GetSpacesSpaceIdWebhooksResponse, error)

	// GetSpacesSpaceIdWebhooksWebhookId request
	GetSpacesSpaceIdWebhooksWebhookIdWithResponse(ctx context.Context, spaceId string, webhookId string, params *GetSpacesSpaceIdWebhooksWebhookIdParams, reqEditors ...RequestEditorFn) (*GetSpacesSpaceIdWebhooksWebhookIdResponse, error)

	// GetSpace request
	GetSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*GetSpaceResponse, error)

	// CreateComponent request with any body
	CreateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error)

	CreateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error)

	// DeleteComponent request
	DeleteComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*DeleteComponentResponse, error)

	// GetComponent request
	GetComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*GetComponentResponse, error)

	// UpdateComponent request with any body
	UpdateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error)

	UpdateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error)
}

type GetSpacesSpaceIdComponentGroupsGroupIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ComponentGroup
}

// Status returns HTTPResponse.Status
func (r GetSpacesSpaceIdComponentGroupsGroupIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacesSpaceIdComponentGroupsGroupIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpacesSpaceIdWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Total    *int       `json:"total,omitempty"`
		Webhooks *[]Webhook `json:"webhooks,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpacesSpaceIdWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacesSpaceIdWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpacesSpaceIdWebhooksWebhookIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
}

// Status returns HTTPResponse.Status
func (r GetSpacesSpaceIdWebhooksWebhookIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpacesSpaceIdWebhooksWebhookIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Component Component
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Component Component
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Component Component
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Component Component
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetSpacesSpaceIdComponentGroupsGroupIdWithResponse request returning *GetSpacesSpaceIdComponentGroupsGroupIdResponse
func (c *ClientWithResponses) GetSpacesSpaceIdComponentGroupsGroupIdWithResponse(ctx context.Context, spaceId int, groupId int, reqEditors ...RequestEditorFn) (*GetSpacesSpaceIdComponentGroupsGroupIdResponse, error) {
	rsp, err := c.GetSpacesSpaceIdComponentGroupsGroupId(ctx, spaceId, groupId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacesSpaceIdComponentGroupsGroupIdResponse(rsp)
}

// GetSpacesSpaceIdWebhooksWithResponse request returning *GetSpacesSpaceIdWebhooksResponse
func (c *ClientWithResponses) GetSpacesSpaceIdWebhooksWithResponse(ctx context.Context, spaceId string, params *GetSpacesSpaceIdWebhooksParams, reqEditors ...RequestEditorFn) (*GetSpacesSpaceIdWebhooksResponse, error) {
	rsp, err := c.GetSpacesSpaceIdWebhooks(ctx, spaceId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacesSpaceIdWebhooksResponse(rsp)
}

// GetSpacesSpaceIdWebhooksWebhookIdWithResponse request returning *GetSpacesSpaceIdWebhooksWebhookIdResponse
func (c *ClientWithResponses) GetSpacesSpaceIdWebhooksWebhookIdWithResponse(ctx context.Context, spaceId string, webhookId string, params *GetSpacesSpaceIdWebhooksWebhookIdParams, reqEditors ...RequestEditorFn) (*GetSpacesSpaceIdWebhooksWebhookIdResponse, error) {
	rsp, err := c.GetSpacesSpaceIdWebhooksWebhookId(ctx, spaceId, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpacesSpaceIdWebhooksWebhookIdResponse(rsp)
}

// GetSpaceWithResponse request returning *GetSpaceResponse
func (c *ClientWithResponses) GetSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*GetSpaceResponse, error) {
	rsp, err := c.GetSpace(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceResponse(rsp)
}

// CreateComponentWithBodyWithResponse request with arbitrary body returning *CreateComponentResponse
func (c *ClientWithResponses) CreateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error) {
	rsp, err := c.CreateComponentWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComponentResponse(rsp)
}

func (c *ClientWithResponses) CreateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error) {
	rsp, err := c.CreateComponent(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComponentResponse(rsp)
}

// DeleteComponentWithResponse request returning *DeleteComponentResponse
func (c *ClientWithResponses) DeleteComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*DeleteComponentResponse, error) {
	rsp, err := c.DeleteComponent(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComponentResponse(rsp)
}

// GetComponentWithResponse request returning *GetComponentResponse
func (c *ClientWithResponses) GetComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, reqEditors ...RequestEditorFn) (*GetComponentResponse, error) {
	rsp, err := c.GetComponent(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComponentResponse(rsp)
}

// UpdateComponentWithBodyWithResponse request with arbitrary body returning *UpdateComponentResponse
func (c *ClientWithResponses) UpdateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error) {
	rsp, err := c.UpdateComponentWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentResponse(rsp)
}

func (c *ClientWithResponses) UpdateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id int64, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error) {
	rsp, err := c.UpdateComponent(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentResponse(rsp)
}

// ParseGetSpacesSpaceIdComponentGroupsGroupIdResponse parses an HTTP response from a GetSpacesSpaceIdComponentGroupsGroupIdWithResponse call
func ParseGetSpacesSpaceIdComponentGroupsGroupIdResponse(rsp *http.Response) (*GetSpacesSpaceIdComponentGroupsGroupIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacesSpaceIdComponentGroupsGroupIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ComponentGroup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpacesSpaceIdWebhooksResponse parses an HTTP response from a GetSpacesSpaceIdWebhooksWithResponse call
func ParseGetSpacesSpaceIdWebhooksResponse(rsp *http.Response) (*GetSpacesSpaceIdWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacesSpaceIdWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Total    *int       `json:"total,omitempty"`
			Webhooks *[]Webhook `json:"webhooks,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpacesSpaceIdWebhooksWebhookIdResponse parses an HTTP response from a GetSpacesSpaceIdWebhooksWebhookIdWithResponse call
func ParseGetSpacesSpaceIdWebhooksWebhookIdResponse(rsp *http.Response) (*GetSpacesSpaceIdWebhooksWebhookIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpacesSpaceIdWebhooksWebhookIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpaceResponse parses an HTTP response from a GetSpaceWithResponse call
func ParseGetSpaceResponse(rsp *http.Response) (*GetSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateComponentResponse parses an HTTP response from a CreateComponentWithResponse call
func ParseCreateComponentResponse(rsp *http.Response) (*CreateComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Component Component
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteComponentResponse parses an HTTP response from a DeleteComponentWithResponse call
func ParseDeleteComponentResponse(rsp *http.Response) (*DeleteComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Component Component
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetComponentResponse parses an HTTP response from a GetComponentWithResponse call
func ParseGetComponentResponse(rsp *http.Response) (*GetComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Component Component
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateComponentResponse parses an HTTP response from a UpdateComponentWithResponse call
func ParseUpdateComponentResponse(rsp *http.Response) (*UpdateComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Component Component
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
