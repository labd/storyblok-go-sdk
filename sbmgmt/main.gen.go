// Package sbmgmt provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package sbmgmt

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	uuid "github.com/gofrs/uuid"
	"github.com/oapi-codegen/runtime"
	orderedmap "github.com/wk8/go-ordered-map/v2"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for ComponentIcon.
const (
	ComponentIconBlock             ComponentIcon = "block-@"
	ComponentIconBlock12block      ComponentIcon = "block-1-2block"
	ComponentIconBlockAdd          ComponentIcon = "block-add"
	ComponentIconBlockArrowPointer ComponentIcon = "block-arrow-pointer"
	ComponentIconBlockBlock        ComponentIcon = "block-block"
	ComponentIconBlockBuildin      ComponentIcon = "block-buildin"
	ComponentIconBlockCart         ComponentIcon = "block-cart"
	ComponentIconBlockCenterM      ComponentIcon = "block-center-m"
	ComponentIconBlockComment      ComponentIcon = "block-comment"
	ComponentIconBlockDoc          ComponentIcon = "block-doc"
	ComponentIconBlockDollarSign   ComponentIcon = "block-dollar-sign"
	ComponentIconBlockEmail        ComponentIcon = "block-email"
	ComponentIconBlockImage        ComponentIcon = "block-image"
	ComponentIconBlockKeyboard     ComponentIcon = "block-keyboard"
	ComponentIconBlockLocked       ComponentIcon = "block-locked"
	ComponentIconBlockMapPin       ComponentIcon = "block-map-pin"
	ComponentIconBlockMobile       ComponentIcon = "block-mobile"
	ComponentIconBlockMonitor      ComponentIcon = "block-monitor"
	ComponentIconBlockPaycard      ComponentIcon = "block-paycard"
	ComponentIconBlockResizeFc     ComponentIcon = "block-resize-fc"
	ComponentIconBlockShare        ComponentIcon = "block-share"
	ComponentIconBlockShield       ComponentIcon = "block-shield"
	ComponentIconBlockShield2      ComponentIcon = "block-shield-2"
	ComponentIconBlockSticker      ComponentIcon = "block-sticker"
	ComponentIconBlockSuitcase     ComponentIcon = "block-suitcase"
	ComponentIconBlockTable        ComponentIcon = "block-table"
	ComponentIconBlockTable2       ComponentIcon = "block-table-2"
	ComponentIconBlockTag          ComponentIcon = "block-tag"
	ComponentIconBlockTextC        ComponentIcon = "block-text-c"
	ComponentIconBlockTextImgC     ComponentIcon = "block-text-img-c"
	ComponentIconBlockTextImgL     ComponentIcon = "block-text-img-l"
	ComponentIconBlockTextImgR     ComponentIcon = "block-text-img-r"
	ComponentIconBlockTextImgRL    ComponentIcon = "block-text-img-r-l"
	ComponentIconBlockTextImgTL    ComponentIcon = "block-text-img-t-l"
	ComponentIconBlockTextImgTR    ComponentIcon = "block-text-img-t-r"
	ComponentIconBlockTextL        ComponentIcon = "block-text-l"
	ComponentIconBlockTextR        ComponentIcon = "block-text-r"
	ComponentIconBlockUnlocked     ComponentIcon = "block-unlocked"
	ComponentIconBlockWallet       ComponentIcon = "block-wallet"
)

// Defines values for ComponentBaseIcon.
const (
	ComponentBaseIconBlock             ComponentBaseIcon = "block-@"
	ComponentBaseIconBlock12block      ComponentBaseIcon = "block-1-2block"
	ComponentBaseIconBlockAdd          ComponentBaseIcon = "block-add"
	ComponentBaseIconBlockArrowPointer ComponentBaseIcon = "block-arrow-pointer"
	ComponentBaseIconBlockBlock        ComponentBaseIcon = "block-block"
	ComponentBaseIconBlockBuildin      ComponentBaseIcon = "block-buildin"
	ComponentBaseIconBlockCart         ComponentBaseIcon = "block-cart"
	ComponentBaseIconBlockCenterM      ComponentBaseIcon = "block-center-m"
	ComponentBaseIconBlockComment      ComponentBaseIcon = "block-comment"
	ComponentBaseIconBlockDoc          ComponentBaseIcon = "block-doc"
	ComponentBaseIconBlockDollarSign   ComponentBaseIcon = "block-dollar-sign"
	ComponentBaseIconBlockEmail        ComponentBaseIcon = "block-email"
	ComponentBaseIconBlockImage        ComponentBaseIcon = "block-image"
	ComponentBaseIconBlockKeyboard     ComponentBaseIcon = "block-keyboard"
	ComponentBaseIconBlockLocked       ComponentBaseIcon = "block-locked"
	ComponentBaseIconBlockMapPin       ComponentBaseIcon = "block-map-pin"
	ComponentBaseIconBlockMobile       ComponentBaseIcon = "block-mobile"
	ComponentBaseIconBlockMonitor      ComponentBaseIcon = "block-monitor"
	ComponentBaseIconBlockPaycard      ComponentBaseIcon = "block-paycard"
	ComponentBaseIconBlockResizeFc     ComponentBaseIcon = "block-resize-fc"
	ComponentBaseIconBlockShare        ComponentBaseIcon = "block-share"
	ComponentBaseIconBlockShield       ComponentBaseIcon = "block-shield"
	ComponentBaseIconBlockShield2      ComponentBaseIcon = "block-shield-2"
	ComponentBaseIconBlockSticker      ComponentBaseIcon = "block-sticker"
	ComponentBaseIconBlockSuitcase     ComponentBaseIcon = "block-suitcase"
	ComponentBaseIconBlockTable        ComponentBaseIcon = "block-table"
	ComponentBaseIconBlockTable2       ComponentBaseIcon = "block-table-2"
	ComponentBaseIconBlockTag          ComponentBaseIcon = "block-tag"
	ComponentBaseIconBlockTextC        ComponentBaseIcon = "block-text-c"
	ComponentBaseIconBlockTextImgC     ComponentBaseIcon = "block-text-img-c"
	ComponentBaseIconBlockTextImgL     ComponentBaseIcon = "block-text-img-l"
	ComponentBaseIconBlockTextImgR     ComponentBaseIcon = "block-text-img-r"
	ComponentBaseIconBlockTextImgRL    ComponentBaseIcon = "block-text-img-r-l"
	ComponentBaseIconBlockTextImgTL    ComponentBaseIcon = "block-text-img-t-l"
	ComponentBaseIconBlockTextImgTR    ComponentBaseIcon = "block-text-img-t-r"
	ComponentBaseIconBlockTextL        ComponentBaseIcon = "block-text-l"
	ComponentBaseIconBlockTextR        ComponentBaseIcon = "block-text-r"
	ComponentBaseIconBlockUnlocked     ComponentBaseIcon = "block-unlocked"
	ComponentBaseIconBlockWallet       ComponentBaseIcon = "block-wallet"
)

// Defines values for FieldInputConditionalSettingsModificationsDisplay.
const (
	Hide FieldInputConditionalSettingsModificationsDisplay = "hide"
)

// Defines values for FieldInputConditionalSettingsRuleConditionsValidatedObjectFieldAttr.
const (
	Value FieldInputConditionalSettingsRuleConditionsValidatedObjectFieldAttr = "value"
)

// Defines values for FieldInputConditionalSettingsRuleConditionsValidatedObjectType.
const (
	Field FieldInputConditionalSettingsRuleConditionsValidatedObjectType = "field"
)

// Defines values for FieldInputConditionalSettingsRuleConditionsValidation.
const (
	Empty     FieldInputConditionalSettingsRuleConditionsValidation = "empty"
	Equals    FieldInputConditionalSettingsRuleConditionsValidation = "equals"
	NotEmpty  FieldInputConditionalSettingsRuleConditionsValidation = "not_empty"
	NotEquals FieldInputConditionalSettingsRuleConditionsValidation = "not_equals"
)

// Defines values for FieldInputConditionalSettingsRuleMatch.
const (
	All FieldInputConditionalSettingsRuleMatch = "all"
	Any FieldInputConditionalSettingsRuleMatch = "any"
)

// AssetFolder defines model for AssetFolder.
type AssetFolder struct {
	// Id The ID of the asset folder
	Id int64 `json:"id"`

	// Name The name of the asset folder
	Name string `json:"name"`

	// ParentId The ID of the parent folder
	ParentId *int64 `json:"parent_id,omitempty"`

	// ParentUuid The UUID of the asset folder
	ParentUuid *string `json:"parent_uuid,omitempty"`

	// Uuid The UUID of the asset folder
	Uuid string `json:"uuid"`
}

// AssetFolderBase defines model for AssetFolderBase.
type AssetFolderBase struct {
	// Name The name of the asset folder
	Name string `json:"name"`

	// ParentId The ID of the parent folder
	ParentId *int64 `json:"parent_id,omitempty"`
}

// AssetFolderCreateInput defines model for AssetFolderCreateInput.
type AssetFolderCreateInput struct {
	AssetFolder AssetFolderBase `json:"asset_folder"`
}

// AssetFolderUpdateInput defines model for AssetFolderUpdateInput.
type AssetFolderUpdateInput = AssetFolderCreateInput

// Component defines model for Component.
type Component struct {
	// Color Css color used as background for the icon
	Color *string `json:"color,omitempty"`

	// ComponentGroupUuid The component group uuid of the component
	ComponentGroupUuid *uuid.UUID `json:"component_group_uuid,omitempty"`

	// CreatedAt The creation timestamp of the component
	CreatedAt time.Time `json:"created_at"`

	// DisplayName The display name of the component
	DisplayName *string `json:"display_name,omitempty"`

	// Icon An optional icon for the component to identify this component type in the interface
	Icon *ComponentIcon `json:"icon,omitempty"`

	// Id The ID of the component
	Id int64 `json:"id"`

	// Image URL to the preview image, if uploaded
	Image *string `json:"image,omitempty"`

	// IsNestable Component should be insertable in blocks field type fields
	IsNestable *bool `json:"is_nestable,omitempty"`

	// IsRoot Component should be usable as a Content Type
	IsRoot *bool `json:"is_root,omitempty"`

	// Name Technical name used for component property in entries
	Name string `json:"name"`

	// PresetId The ID of the preset associated with the component (null if not set)
	PresetId *string `json:"preset_id,omitempty"`

	// PreviewField Define the field that should be used for preview in the interface
	PreviewField *string `json:"preview_field,omitempty"`

	// PreviewTmpl Define the template that should be used for preview in the interface
	PreviewTmpl *string `json:"preview_tmpl,omitempty"`

	// RealName The real name of the component
	RealName *string `json:"real_name,omitempty"`

	// Schema The definition of fields (schema) for this component
	Schema *orderedmap.OrderedMap[string, FieldInput] `json:"schema,omitempty"`

	// UpdatedAt The update timestamp of the component
	UpdatedAt time.Time `json:"updated_at"`
}

// ComponentIcon An optional icon for the component to identify this component type in the interface
type ComponentIcon string

// ComponentBase defines model for ComponentBase.
type ComponentBase struct {
	// Color Css color used as background for the icon
	Color *string `json:"color,omitempty"`

	// ComponentGroupUuid The component group uuid of the component
	ComponentGroupUuid *uuid.UUID `json:"component_group_uuid,omitempty"`

	// DisplayName The display name of the component
	DisplayName *string `json:"display_name,omitempty"`

	// Icon An optional icon for the component to identify this component type in the interface
	Icon *ComponentBaseIcon `json:"icon,omitempty"`

	// Image URL to the preview image, if uploaded
	Image *string `json:"image,omitempty"`

	// IsNestable Component should be insertable in blocks field type fields
	IsNestable *bool `json:"is_nestable,omitempty"`

	// IsRoot Component should be usable as a Content Type
	IsRoot *bool `json:"is_root,omitempty"`

	// Name Technical name used for component property in entries
	Name string `json:"name"`

	// PreviewField Define the field that should be used for preview in the interface
	PreviewField *string `json:"preview_field,omitempty"`

	// PreviewTmpl Define the template that should be used for preview in the interface
	PreviewTmpl *string `json:"preview_tmpl,omitempty"`

	// Schema The definition of fields (schema) for this component
	Schema *orderedmap.OrderedMap[string, FieldInput] `json:"schema,omitempty"`
}

// ComponentBaseIcon An optional icon for the component to identify this component type in the interface
type ComponentBaseIcon string

// ComponentCreateInput defines model for ComponentCreateInput.
type ComponentCreateInput struct {
	Component ComponentBase `json:"component"`
}

// ComponentGroup defines model for ComponentGroup.
type ComponentGroup struct {
	// Id The ID of the component group
	Id int64 `json:"id"`

	// Name The name of the component group
	Name string `json:"name"`

	// Uuid The UUID of the component group
	Uuid uuid.UUID `json:"uuid"`
}

// ComponentGroupBase defines model for ComponentGroupBase.
type ComponentGroupBase struct {
	// Name The name of the component group
	Name string `json:"name"`
}

// ComponentGroupCreateInput defines model for ComponentGroupCreateInput.
type ComponentGroupCreateInput struct {
	ComponentGroup ComponentGroupBase `json:"component_group"`
}

// ComponentGroupUpdateInput defines model for ComponentGroupUpdateInput.
type ComponentGroupUpdateInput = ComponentGroupCreateInput

// ComponentUpdateInput defines model for ComponentUpdateInput.
type ComponentUpdateInput = ComponentCreateInput

// Datasource defines model for Datasource.
type Datasource struct {
	// CreatedAt The creation timestamp of the datasource
	CreatedAt time.Time `json:"created_at"`

	// Id The ID of the datasource
	Id int64 `json:"id"`

	// Name The name of the data source
	Name string `json:"name"`

	// Slug The slug of the data source
	Slug string `json:"slug"`

	// UpdatedAt The update timestamp of the datasource
	UpdatedAt time.Time `json:"updated_at"`
}

// DatasourceBase defines model for DatasourceBase.
type DatasourceBase struct {
	// Name The name of the data source
	Name string `json:"name"`

	// Slug The slug of the data source
	Slug string `json:"slug"`
}

// DatasourceCreateInput defines model for DatasourceCreateInput.
type DatasourceCreateInput struct {
	Datasource DatasourceBase `json:"datasource"`
}

// DatasourceEntry defines model for DatasourceEntry.
type DatasourceEntry struct {
	// DatasourceId The ID of the datasource containing the entry
	DatasourceId *int64 `json:"datasource_id,omitempty"`

	// Id The ID of the datasource entry
	Id int64 `json:"id"`

	// Name The name of the datasource entry
	Name string `json:"name"`

	// Value The value of the datasource entry
	Value *string `json:"value,omitempty"`
}

// DatasourceEntryBase defines model for DatasourceEntryBase.
type DatasourceEntryBase struct {
	// DatasourceId The ID of the datasource containing the entry
	DatasourceId *int64 `json:"datasource_id,omitempty"`

	// Name The name of the datasource entry
	Name string `json:"name"`

	// Value The value of the datasource entry
	Value *string `json:"value,omitempty"`
}

// DatasourceEntryCreateInput defines model for DatasourceEntryCreateInput.
type DatasourceEntryCreateInput struct {
	DatasourceEntry DatasourceEntryBase `json:"datasource_entry"`
}

// DatasourceEntryUpdateInput defines model for DatasourceEntryUpdateInput.
type DatasourceEntryUpdateInput = DatasourceEntryCreateInput

// DatasourceUpdateInput defines model for DatasourceUpdateInput.
type DatasourceUpdateInput = DatasourceCreateInput

// FieldInput defines model for FieldInput.
type FieldInput struct {
	// AddHttps Prepends https: to stop usage of relative protocol
	AddHttps *bool `json:"add_https,omitempty"`

	// AllowTargetBlank Allow target blank for links in richtext
	AllowTargetBlank *bool `json:"allow_target_blank,omitempty"`

	// AssetFolderId Default asset folder numeric id to store uploaded image of that field
	AssetFolderId *int64 `json:"asset_folder_id,omitempty"`

	// CanSync Advanced usage to sync with field in preview
	CanSync *bool `json:"can_sync,omitempty"`

	// ComponentWhitelist Array of component/content type names: ["post","page","product"]
	ComponentWhitelist *[]string `json:"component_whitelist,omitempty"`

	// ConditionalSettings Array containing the object with information about conditions set on the field
	ConditionalSettings *[]struct {
		// Modifications List of modifications to be applied to the field. Only 1 modification can be applied at a time (hide OR required)
		Modifications *[]struct {
			Display  *FieldInputConditionalSettingsModificationsDisplay `json:"display,omitempty"`
			Required *bool                                              `json:"required,omitempty"`
		} `json:"modifications,omitempty"`

		// RuleConditions Conditional rules to be applied to the field
		RuleConditions *[]struct {
			ValidatedObject *struct {
				FieldAttr *FieldInputConditionalSettingsRuleConditionsValidatedObjectFieldAttr `json:"field_attr,omitempty"`
				FieldKey  *string                                                              `json:"field_key,omitempty"`
				Type      *FieldInputConditionalSettingsRuleConditionsValidatedObjectType      `json:"type,omitempty"`
			} `json:"validated_object,omitempty"`
			Validation *FieldInputConditionalSettingsRuleConditionsValidation `json:"validation,omitempty"`
			Value      *string                                                `json:"value"`
		} `json:"rule_conditions,omitempty"`

		// RuleMatch Define if all or any of the conditions should be met to apply the modifications
		RuleMatch *FieldInputConditionalSettingsRuleMatch `json:"rule_match,omitempty"`
	} `json:"conditional_settings,omitempty"`

	// CustomizeToolbar Customize toolbar in richtext or markdown
	CustomizeToolbar *bool `json:"customize_toolbar,omitempty"`

	// DatasourceSlug Define selectable datasources string; Effects editor only if source=internal
	DatasourceSlug *string `json:"datasource_slug,omitempty"`

	// DefaultValue Default value for the field; Can be an escaped JSON object
	DefaultValue *string `json:"default_value,omitempty"`

	// Description Description shown in the editor interface
	Description *string `json:"description,omitempty"`

	// DisableTime Disables time selection from date picker; Default: false
	DisableTime *bool `json:"disable_time,omitempty"`

	// DisplayName Name of the field for the editor interface
	DisplayName *string `json:"display_name,omitempty"`

	// ExternalDatasource Define external datasource JSON Url; Effects editor only if source=external
	ExternalDatasource *string `json:"external_datasource,omitempty"`

	// FieldType Name of the custom field type plugin
	FieldType *string `json:"field_type,omitempty"`

	// Filetypes Array of file type names: ["images", "videos", "audios", "texts"]
	Filetypes         *[]string `json:"filetypes,omitempty"`
	FilterContentType *[]string `json:"filter_content_type,omitempty"`

	// FolderSlug Filter on selectable stories path; Effects editor only if source=internal_stories; In case you have a multi-language folder structure you can add the '{0}' placeholder and the path will be adapted dynamically. Examples: "{0}/categories/", {0}/{1}/categories/
	FolderSlug *string `json:"folder_slug,omitempty"`

	// ForceLinkScope Force link scope to be internal or external
	ForceLinkScope *bool `json:"force_link_scope,omitempty"`

	// ImageCrop Activate force crop for images: (true/false)
	ImageCrop *bool `json:"image_crop,omitempty"`

	// ImageHeight Define height in px or height ratio if keep_image_size is enabled
	ImageHeight *string `json:"image_height,omitempty"`

	// ImageWidth Define width in px or width ratio if keep_image_size is enabled
	ImageWidth *string `json:"image_width,omitempty"`

	// KeepImageSize Keep original size: (true/false)
	KeepImageSize *bool `json:"keep_image_size,omitempty"`

	// Keys Array of field keys to include in this section
	Keys *[]string `json:"keys,omitempty"`

	// LinkScope Filter on selectable stories path; In case you have a multi-language folder structure you can add the '{0}' placeholder and the path will be adapted dynamically. Examples: "{0}/categories/", {0}/{1}/categories/
	LinkScope *string `json:"link_scope,omitempty"`

	// MaxLength Set the max length of the input string
	MaxLength *int64 `json:"max_length,omitempty"`

	// MaxOptions Maximum amount of options in this field
	MaxOptions *int64 `json:"max_options,omitempty"`

	// Maximum Maximum amount of bloks in this field
	Maximum *int64 `json:"maximum,omitempty"`

	// MinOptions Minimum amount of options in this field
	MinOptions *int64 `json:"min_options,omitempty"`

	// Minimum Minimum amount of bloks in this field
	Minimum *int64 `json:"minimum,omitempty"`

	// NoTranslate Should be excluded in translation export
	NoTranslate *bool `json:"no_translate,omitempty"`

	// Options Array of datasource entries [{name:"", value:""}]; Effects editor only if source=undefined
	Options *[]FieldOption `json:"options,omitempty"`

	// Pos The position of the field
	Pos int64 `json:"pos"`

	// Regex Client Regex validation for the field
	Regex *string `json:"regex,omitempty"`

	// Required Is field required; Default: false
	Required *bool `json:"required,omitempty"`

	// RestrictComponents Activate restriction nestable component option; Default: false
	RestrictComponents *bool `json:"restrict_components,omitempty"`

	// RestrictContentTypes Activate restriction content type option
	RestrictContentTypes *bool `json:"restrict_content_types,omitempty"`

	// RichMarkdown Enable rich markdown view by default (true/false)
	RichMarkdown *bool `json:"rich_markdown,omitempty"`

	// Rtl Enable global RTL for this field
	Rtl *bool `json:"rtl,omitempty"`

	// Source Possible values: undefined: Self; internal_stories: Stories; internal: Datasource; external: API Endpoint in Datasource Entries Array Format
	Source *string `json:"source,omitempty"`

	// Toolbar Array of toolbar options
	Toolbar *[]string `json:"toolbar,omitempty"`

	// Tooltip Show the description as a tooltip
	Tooltip *bool `json:"tooltip,omitempty"`

	// Translatable Can field be translated; Default: false
	Translatable *bool `json:"translatable,omitempty"`

	// Type The type of the field
	Type string `json:"type"`

	// UseUuid Default: true; available in option and source=internal_stories
	UseUuid *bool `json:"use_uuid,omitempty"`
}

// FieldInputConditionalSettingsModificationsDisplay defines model for FieldInput.ConditionalSettings.Modifications.Display.
type FieldInputConditionalSettingsModificationsDisplay string

// FieldInputConditionalSettingsRuleConditionsValidatedObjectFieldAttr defines model for FieldInput.ConditionalSettings.RuleConditions.ValidatedObject.FieldAttr.
type FieldInputConditionalSettingsRuleConditionsValidatedObjectFieldAttr string

// FieldInputConditionalSettingsRuleConditionsValidatedObjectType defines model for FieldInput.ConditionalSettings.RuleConditions.ValidatedObject.Type.
type FieldInputConditionalSettingsRuleConditionsValidatedObjectType string

// FieldInputConditionalSettingsRuleConditionsValidation defines model for FieldInput.ConditionalSettings.RuleConditions.Validation.
type FieldInputConditionalSettingsRuleConditionsValidation string

// FieldInputConditionalSettingsRuleMatch Define if all or any of the conditions should be met to apply the modifications
type FieldInputConditionalSettingsRuleMatch string

// FieldOption defines model for FieldOption.
type FieldOption struct {
	Name  string `json:"name"`
	Value string `json:"value"`
}

// Space defines model for Space.
type Space struct {
	// ApiLogsPerMonth An array of API logs per month
	ApiLogsPerMonth []interface{} `json:"api_logs_per_month"`

	// ApiRequests The total number of API requests allowed
	ApiRequests int `json:"api_requests"`

	// AssetsCount The count of assets in the space
	AssetsCount int `json:"assets_count"`

	// Collaborators An array of collaborators
	Collaborators []interface{} `json:"collaborators"`

	// CreatedAt The creation timestamp of the space
	CreatedAt time.Time `json:"created_at"`

	// Domain The domain of the space
	Domain string `json:"domain"`

	// Environments The environments of the space (null if not set)
	Environments *string `json:"environments,omitempty"`

	// Euid The EUID of the space (null if not set)
	Euid *string `json:"euid,omitempty"`

	// ExceededRequests The count of exceeded API requests
	ExceededRequests int `json:"exceeded_requests"`

	// FirstToken The first token of the space
	FirstToken string `json:"first_token"`

	// HasPendingTasks Indicates whether the space has pending tasks
	HasPendingTasks bool `json:"has_pending_tasks"`

	// HasSlackWebhook Indicates whether the space has a Slack webhook
	HasSlackWebhook bool `json:"has_slack_webhook"`

	// Limits The limits of the space
	Limits *map[string]interface{} `json:"limits,omitempty"`

	// Name The name of the space
	Name string `json:"name"`

	// Options The options of the space
	Options map[string]interface{} `json:"options"`

	// Owner The owner of the space
	Owner map[string]interface{} `json:"owner"`

	// Plan The plan of the space
	Plan string `json:"plan"`

	// PlanLevel The plan level of the space
	PlanLevel int `json:"plan_level"`

	// RequestCountToday The count of requests made today
	RequestCountToday int `json:"request_count_today"`

	// Role The role of the user in the space
	Role string `json:"role"`

	// SearchblokId The Searchblok ID of the space (null if not set)
	SearchblokId *string `json:"searchblok_id,omitempty"`

	// Settings An array of settings
	Settings []interface{} `json:"settings"`

	// StoriesCount The count of stories in the space
	StoriesCount int `json:"stories_count"`

	// StoryPublishedHook The story published hook of the space (null if not set)
	StoryPublishedHook *string `json:"story_published_hook,omitempty"`

	// Trial Indicates whether the space is in trial mode
	Trial bool `json:"trial"`

	// UpdatedAt The update timestamp of the space
	UpdatedAt time.Time `json:"updated_at"`
}

// SpaceBase defines model for SpaceBase.
type SpaceBase struct {
	// Domain The domain of the space
	Domain *string `json:"domain,omitempty"`

	// Environments The environments of the space (null if not set)
	Environments *string `json:"environments,omitempty"`

	// Name The name of the space
	Name string `json:"name"`

	// SearchblokId The Searchblok ID of the space (null if not set)
	SearchblokId *string `json:"searchblok_id,omitempty"`

	// StoryPublishedHook The story published hook of the space (null if not set)
	StoryPublishedHook *string `json:"story_published_hook,omitempty"`
}

// SpaceCreateInput defines model for SpaceCreateInput.
type SpaceCreateInput struct {
	Space SpaceBase `json:"space"`
}

// SpaceDuplicateInput defines model for SpaceDuplicateInput.
type SpaceDuplicateInput struct {
	// DupId The numeric id of the original space
	DupId *int      `json:"dup_id,omitempty"`
	Space SpaceBase `json:"space"`
}

// SpaceRole defines model for SpaceRole.
type SpaceRole struct {
	AllowedLanguages *[]string `json:"allowed_languages,omitempty"`
	AllowedPaths     *[]string `json:"allowed_paths,omitempty"`
	BranchIds        *[]int    `json:"branch_ids,omitempty"`
	ComponentIds     *[]int    `json:"component_ids,omitempty"`
	DatasourceIds    *[]int    `json:"datasource_ids,omitempty"`
	ExtId            *string   `json:"ext_id,omitempty"`
	FieldPermissions *[]string `json:"field_permissions,omitempty"`

	// Id Numeric Unique ID
	Id                       int       `json:"id"`
	Permissions              *[]string `json:"permissions,omitempty"`
	ReadonlyFieldPermissions *[]string `json:"readonly_field_permissions,omitempty"`
	ResolvedAllowedPaths     *[]string `json:"resolved_allowed_paths,omitempty"`
	Role                     string    `json:"role"`
	Subtitle                 *string   `json:"subtitle,omitempty"`
}

// SpaceRoleBase defines model for SpaceRoleBase.
type SpaceRoleBase struct {
	AllowedLanguages         *[]string `json:"allowed_languages,omitempty"`
	AllowedPaths             *[]string `json:"allowed_paths,omitempty"`
	BranchIds                *[]int    `json:"branch_ids,omitempty"`
	ComponentIds             *[]int    `json:"component_ids,omitempty"`
	DatasourceIds            *[]int    `json:"datasource_ids,omitempty"`
	ExtId                    *string   `json:"ext_id,omitempty"`
	FieldPermissions         *[]string `json:"field_permissions,omitempty"`
	Permissions              *[]string `json:"permissions,omitempty"`
	ReadonlyFieldPermissions *[]string `json:"readonly_field_permissions,omitempty"`
	ResolvedAllowedPaths     *[]string `json:"resolved_allowed_paths,omitempty"`
	Role                     string    `json:"role"`
	Subtitle                 *string   `json:"subtitle,omitempty"`
}

// SpaceRoleCreateInput defines model for SpaceRoleCreateInput.
type SpaceRoleCreateInput struct {
	SpaceRole *SpaceRoleBase `json:"space_role,omitempty"`
}

// SpaceRoleUpdateInput defines model for SpaceRoleUpdateInput.
type SpaceRoleUpdateInput struct {
	SpaceRole *SpaceRoleBase `json:"space_role,omitempty"`
}

// SpaceUpdateInput defines model for SpaceUpdateInput.
type SpaceUpdateInput struct {
	// BillingAddress The billing address of the space
	BillingAddress *map[string]interface{} `json:"billing_address,omitempty"`

	// DefaultRoot The default root of the space
	DefaultRoot *string `json:"default_root,omitempty"`

	// Duplicatable Indicates whether the space is duplicatable (null if not set)
	Duplicatable *string `json:"duplicatable,omitempty"`

	// Id The ID of the space
	Id *int64 `json:"id,omitempty"`

	// Options The options of the space
	Options *map[string]interface{} `json:"options,omitempty"`

	// OwnerId The ID of the owner of the space
	OwnerId *int `json:"owner_id,omitempty"`

	// ParentId The ID of the parent space (null if not set)
	ParentId *int `json:"parent_id,omitempty"`

	// Routes An array of routes
	Routes *[]interface{} `json:"routes,omitempty"`
	Space  SpaceBase      `json:"space"`

	// UniqDomain The unique domain of the space (null if not set)
	UniqDomain *string `json:"uniq_domain,omitempty"`
}

// Story defines model for Story.
type Story struct {
	Alternates []map[string]interface{} `json:"alternates"`
	CanNotView bool                     `json:"can_not_view"`

	// Content The content of the story
	Content *map[string]interface{} `json:"content,omitempty"`

	// CreatedAt The creation timestamp of the story
	CreatedAt time.Time `json:"created_at"`

	// DefaultRoot Default content type/root component. (*Required if is_folder is true)
	DefaultRoot *bool `json:"default_root,omitempty"`

	// DeletedAt The deletion timestamp of the story
	DeletedAt *time.Time `json:"deleted_at,omitempty"`

	// DisableFeEditor Is side by side editor disabled for all entries in folder (true/false)
	DisableFeEditor *bool `json:"disable_fe_editor,omitempty"`

	// ExpireAt The expire timestamp of the story
	ExpireAt *time.Time `json:"expire_at,omitempty"`

	// FirstPublishedAt First publishing date (Format: YYYY-mm-dd HH:MM)
	FirstPublishedAt *string `json:"first_published_at,omitempty"`
	FullSlug         *string `json:"full_slug,omitempty"`

	// Id The ID of the story
	Id int64 `json:"id"`

	// IsFolder Flag indicating whether the story is a folder
	IsFolder    *bool `json:"is_folder,omitempty"`
	IsScheduled *bool `json:"is_scheduled,omitempty"`

	// IsStartpage Flag indicating whether the story is the start page
	IsStartpage *bool `json:"is_startpage,omitempty"`
	LastAuthor  struct {
		FriendlyName *string `json:"friendly_name,omitempty"`
		Id           *int    `json:"id,omitempty"`
		Userid       *string `json:"userid,omitempty"`
	} `json:"last_author"`
	LocalizedPaths []map[string]interface{} `json:"localized_paths"`
	MetaData       *map[string]interface{}  `json:"meta_data,omitempty"`

	// Name The name of the story
	Name   string                  `json:"name"`
	Parent *map[string]interface{} `json:"parent,omitempty"`

	// ParentId The ID of the parent story/folder
	ParentId *int `json:"parent_id,omitempty"`

	// ParentUuid The UUID of the story
	ParentUuid *string `json:"parent_uuid,omitempty"`

	// Path Given real path, used in the preview editor
	Path   *string `json:"path,omitempty"`
	Pinned bool    `json:"pinned"`

	// Position The position of the story/folder within its parent
	Position     int `json:"position"`
	PreviewToken struct {
		Timestamp *string `json:"timestamp,omitempty"`
		Token     *string `json:"token,omitempty"`
	} `json:"preview_token"`

	// PublishAt The publish timestamp of the story
	PublishAt *time.Time `json:"publish_at,omitempty"`

	// Slug The slug of the story
	Slug                      string                   `json:"slug"`
	SortByDate                *string                  `json:"sort_by_date,omitempty"`
	SpaceRoleIds              []int                    `json:"space_role_ids"`
	TagList                   *[]string                `json:"tag_list,omitempty"`
	TranslatedSlugs           []map[string]interface{} `json:"translated_slugs"`
	TranslatedSlugsAttributes *[]struct {
		Lang *string `json:"lang,omitempty"`
		Name *string `json:"name,omitempty"`
		Slug *string `json:"slug,omitempty"`
	} `json:"translated_slugs_attributes,omitempty"`
	TranslatedStories  []interface{} `json:"translated_stories"`
	UnpublishedChanges *bool         `json:"unpublished_changes,omitempty"`

	// UpdatedAt The update timestamp of the story
	UpdatedAt time.Time `json:"updated_at"`
	UserIds   []int     `json:"user_ids"`

	// Uuid The UUID of the story
	Uuid string `json:"uuid"`
}

// StoryBase defines model for StoryBase.
type StoryBase struct {
	// Content The content of the story
	Content *map[string]interface{} `json:"content,omitempty"`

	// DefaultRoot Default content type/root component. (*Required if is_folder is true)
	DefaultRoot *bool `json:"default_root,omitempty"`

	// DisableFeEditor Is side by side editor disabled for all entries in folder (true/false)
	DisableFeEditor *bool `json:"disable_fe_editor,omitempty"`

	// FirstPublishedAt First publishing date (Format: YYYY-mm-dd HH:MM)
	FirstPublishedAt *string `json:"first_published_at,omitempty"`

	// IsFolder Flag indicating whether the story is a folder
	IsFolder *bool `json:"is_folder,omitempty"`

	// IsStartpage Flag indicating whether the story is the start page
	IsStartpage *bool `json:"is_startpage,omitempty"`

	// Name The name of the story
	Name string `json:"name"`

	// ParentId The ID of the parent story/folder
	ParentId *int `json:"parent_id,omitempty"`

	// Path Given real path, used in the preview editor
	Path *string `json:"path,omitempty"`

	// Position The position of the story/folder within its parent
	Position *int `json:"position,omitempty"`

	// Slug The slug of the story
	Slug                      string `json:"slug"`
	TranslatedSlugsAttributes *[]struct {
		Lang *string `json:"lang,omitempty"`
		Name *string `json:"name,omitempty"`
		Slug *string `json:"slug,omitempty"`
	} `json:"translated_slugs_attributes,omitempty"`
}

// StoryCreateInput defines model for StoryCreateInput.
type StoryCreateInput struct {
	// Publish If '1' it will publish the story, 'publish' must be omitted if publication is not desired
	Publish   *int64    `json:"publish,omitempty"`
	ReleaseId *int64    `json:"release_id,omitempty"`
	Story     StoryBase `json:"story"`
}

// StoryUpdateInput defines model for StoryUpdateInput.
type StoryUpdateInput struct {
	// ForceUpdate If '1' it will overwrite a locked story
	ForceUpdate *int    `json:"force_update,omitempty"`
	GroupId     *int    `json:"group_id,omitempty"`
	Lang        *string `json:"lang,omitempty"`

	// Publish If '1' it will publish the story, 'publish' must be omitted if publication is not desired
	Publish   *int64    `json:"publish,omitempty"`
	ReleaseId *int64    `json:"release_id,omitempty"`
	Story     StoryBase `json:"story"`
}

// Version defines model for Version.
type Version struct {
	Author    *string    `json:"author,omitempty"`
	AuthorId  *int       `json:"author_id,omitempty"`
	CreatedAt *time.Time `json:"created_at,omitempty"`
	Event     *string    `json:"event,omitempty"`
	Id        *int       `json:"id,omitempty"`
	IsDraft   *bool      `json:"is_draft,omitempty"`
	ItemId    *int       `json:"item_id,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	// Actions The actions of the webhook
	Actions []string `json:"actions"`

	// Activated The activation status of the webhook
	Activated bool       `json:"activated"`
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description The description of the webhook
	Description *string `json:"description,omitempty"`

	// Endpoint The endpoint of the webhook
	Endpoint string `json:"endpoint"`

	// Id The id of the webhook
	Id int64 `json:"id"`

	// Name The name of the data source
	Name string `json:"name"`

	// Secret The secret of the webhook
	Secret    string     `json:"secret"`
	UpdatedAt *time.Time `json:"updated_at,omitempty"`
}

// WebhookCreateInput defines model for WebhookCreateInput.
type WebhookCreateInput struct {
	// Actions The actions of the webhook
	Actions []string `json:"actions"`

	// Activated The activation status of the webhook
	Activated bool `json:"activated"`

	// Description The description of the webhook
	Description *string `json:"description,omitempty"`

	// Endpoint The endpoint of the webhook
	Endpoint string `json:"endpoint"`

	// Name The name of the data source
	Name string `json:"name"`

	// Secret The secret of the webhook
	Secret string `json:"secret"`
}

// WebhookUpdateInput defines model for WebhookUpdateInput.
type WebhookUpdateInput struct {
	// Actions The actions of the webhook
	Actions []string `json:"actions"`

	// Activated The activation status of the webhook
	Activated bool `json:"activated"`

	// Description The description of the webhook
	Description *string `json:"description,omitempty"`

	// Endpoint The endpoint of the webhook
	Endpoint string `json:"endpoint"`

	// Name The name of the data source
	Name string `json:"name"`

	// Secret The secret of the webhook
	Secret string `json:"secret"`
}

// IdParam defines model for idParam.
type IdParam = int64

// SpaceIdParam defines model for spaceIdParam.
type SpaceIdParam = int64

// SpaceRoleIdParam defines model for spaceRoleIdParam.
type SpaceRoleIdParam = int64

// UpdateDatasourceJSONBody defines parameters for UpdateDatasource.
type UpdateDatasourceJSONBody struct {
	Datasource *DatasourceUpdateInput `json:"datasource,omitempty"`
}

// CreateWebhookJSONBody defines parameters for CreateWebhook.
type CreateWebhookJSONBody struct {
	WebhookEndpoint WebhookCreateInput `json:"webhook_endpoint"`
}

// UpdateWebhookJSONBody defines parameters for UpdateWebhook.
type UpdateWebhookJSONBody struct {
	WebhookEndpoint WebhookUpdateInput `json:"webhook_endpoint"`
}

// CreateSpaceJSONRequestBody defines body for CreateSpace for application/json ContentType.
type CreateSpaceJSONRequestBody = SpaceCreateInput

// DuplicateSpaceJSONRequestBody defines body for DuplicateSpace for application/json ContentType.
type DuplicateSpaceJSONRequestBody = SpaceDuplicateInput

// UpdateSpaceJSONRequestBody defines body for UpdateSpace for application/json ContentType.
type UpdateSpaceJSONRequestBody = SpaceUpdateInput

// CreateAssetFolderJSONRequestBody defines body for CreateAssetFolder for application/json ContentType.
type CreateAssetFolderJSONRequestBody = AssetFolderCreateInput

// UpdateAssetFolderJSONRequestBody defines body for UpdateAssetFolder for application/json ContentType.
type UpdateAssetFolderJSONRequestBody = AssetFolderUpdateInput

// CreateComponentGroupJSONRequestBody defines body for CreateComponentGroup for application/json ContentType.
type CreateComponentGroupJSONRequestBody = ComponentGroupCreateInput

// UpdateComponentGroupJSONRequestBody defines body for UpdateComponentGroup for application/json ContentType.
type UpdateComponentGroupJSONRequestBody = ComponentGroupUpdateInput

// CreateComponentJSONRequestBody defines body for CreateComponent for application/json ContentType.
type CreateComponentJSONRequestBody = ComponentCreateInput

// UpdateComponentJSONRequestBody defines body for UpdateComponent for application/json ContentType.
type UpdateComponentJSONRequestBody = ComponentUpdateInput

// CreateDatasourceEntryJSONRequestBody defines body for CreateDatasourceEntry for application/json ContentType.
type CreateDatasourceEntryJSONRequestBody = DatasourceEntryCreateInput

// UpdateDatasourceEntryJSONRequestBody defines body for UpdateDatasourceEntry for application/json ContentType.
type UpdateDatasourceEntryJSONRequestBody = DatasourceEntryUpdateInput

// CreateDatasourceJSONRequestBody defines body for CreateDatasource for application/json ContentType.
type CreateDatasourceJSONRequestBody = DatasourceCreateInput

// UpdateDatasourceJSONRequestBody defines body for UpdateDatasource for application/json ContentType.
type UpdateDatasourceJSONRequestBody UpdateDatasourceJSONBody

// CreateSpaceRoleJSONRequestBody defines body for CreateSpaceRole for application/json ContentType.
type CreateSpaceRoleJSONRequestBody = SpaceRoleCreateInput

// UpdateSpaceRoleJSONRequestBody defines body for UpdateSpaceRole for application/json ContentType.
type UpdateSpaceRoleJSONRequestBody = SpaceRoleUpdateInput

// CreateStoryJSONRequestBody defines body for CreateStory for application/json ContentType.
type CreateStoryJSONRequestBody = StoryCreateInput

// UpdateStoryJSONRequestBody defines body for UpdateStory for application/json ContentType.
type UpdateStoryJSONRequestBody = StoryUpdateInput

// CreateWebhookJSONRequestBody defines body for CreateWebhook for application/json ContentType.
type CreateWebhookJSONRequestBody CreateWebhookJSONBody

// UpdateWebhookJSONRequestBody defines body for UpdateWebhook for application/json ContentType.
type UpdateWebhookJSONRequestBody UpdateWebhookJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CompareStory request
	CompareStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PublishStory request
	PublishStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnpublishStory request
	UnpublishStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VersionsStory request
	VersionsStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSpaces request
	ListSpaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpaceWithBody request with any body
	CreateSpaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpace(ctx context.Context, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpace request
	DeleteSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpace request
	GetSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DuplicateSpaceWithBody request with any body
	DuplicateSpaceWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DuplicateSpace(ctx context.Context, spaceId SpaceIdParam, body DuplicateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpaceWithBody request with any body
	UpdateSpaceWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpace(ctx context.Context, spaceId SpaceIdParam, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListAssetFolders request
	ListAssetFolders(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAssetFolderWithBody request with any body
	CreateAssetFolderWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAssetFolder(ctx context.Context, spaceId SpaceIdParam, body CreateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAssetFolder request
	DeleteAssetFolder(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAssetFolder request
	GetAssetFolder(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateAssetFolderWithBody request with any body
	UpdateAssetFolderWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateAssetFolder(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BackupSpace request
	BackupSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListComponentGroups request
	ListComponentGroups(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComponentGroupWithBody request with any body
	CreateComponentGroupWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComponentGroup(ctx context.Context, spaceId SpaceIdParam, body CreateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComponentGroup request
	DeleteComponentGroup(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComponentGroup request
	GetComponentGroup(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComponentGroupWithBody request with any body
	UpdateComponentGroupWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComponentGroup(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListComponents request
	ListComponents(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateComponentWithBody request with any body
	CreateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateComponent(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteComponent request
	DeleteComponent(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetComponent request
	GetComponent(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateComponentWithBody request with any body
	UpdateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateComponent(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatasourceEntries request
	ListDatasourceEntries(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatasourceEntryWithBody request with any body
	CreateDatasourceEntryWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatasourceEntry request
	DeleteDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatasourceEntry request
	GetDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatasourceEntryWithBody request with any body
	UpdateDatasourceEntryWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListDatasources request
	ListDatasources(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDatasourceWithBody request with any body
	CreateDatasourceWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDatasource(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDatasource request
	DeleteDatasource(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDatasource request
	GetDatasource(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateDatasourceWithBody request with any body
	UpdateDatasourceWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateDatasource(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMultipleSpaceRoles request
	GetMultipleSpaceRoles(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateSpaceRoleWithBody request with any body
	CreateSpaceRoleWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateSpaceRole(ctx context.Context, spaceId SpaceIdParam, body CreateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteSpaceRole request
	DeleteSpaceRole(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSpaceRole request
	GetSpaceRole(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSpaceRoleWithBody request with any body
	UpdateSpaceRoleWithBody(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSpaceRole(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, body UpdateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListStories request
	ListStories(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateStoryWithBody request with any body
	CreateStoryWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateStory(ctx context.Context, spaceId SpaceIdParam, body CreateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteStory request
	DeleteStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStory request
	GetStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateStoryWithBody request with any body
	UpdateStoryWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookWithBody request with any body
	CreateWebhookWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhook(ctx context.Context, spaceId SpaceIdParam, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateWebhookWithBody request with any body
	UpdateWebhookWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateWebhook(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CompareStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCompareStoryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PublishStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPublishStoryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnpublishStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnpublishStoryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VersionsStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVersionsStoryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSpaces(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSpacesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpace(ctx context.Context, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuplicateSpaceWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuplicateSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DuplicateSpace(ctx context.Context, spaceId SpaceIdParam, body DuplicateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDuplicateSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpace(ctx context.Context, spaceId SpaceIdParam, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListAssetFolders(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListAssetFoldersRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetFolderWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetFolderRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAssetFolder(ctx context.Context, spaceId SpaceIdParam, body CreateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAssetFolderRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAssetFolder(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAssetFolderRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAssetFolder(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAssetFolderRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetFolderWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetFolderRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateAssetFolder(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateAssetFolderRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BackupSpace(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBackupSpaceRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListComponentGroups(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListComponentGroupsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComponentGroupWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComponentGroupRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComponentGroup(ctx context.Context, spaceId SpaceIdParam, body CreateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComponentGroupRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComponentGroup(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComponentGroupRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComponentGroup(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComponentGroupRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponentGroupWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentGroupRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponentGroup(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentGroupRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListComponents(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListComponentsRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComponentRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateComponent(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateComponentRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteComponent(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteComponentRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetComponent(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetComponentRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponentWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateComponent(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateComponentRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatasourceEntries(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatasourceEntriesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatasourceEntryWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatasourceEntryRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatasourceEntryRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatasourceEntryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatasourceEntryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatasourceEntryWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatasourceEntryRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatasourceEntry(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatasourceEntryRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListDatasources(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDatasourcesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatasourceWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatasourceRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDatasource(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDatasourceRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDatasource(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDatasourceRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDatasource(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDatasourceRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatasourceWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatasourceRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateDatasource(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateDatasourceRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMultipleSpaceRoles(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMultipleSpaceRolesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceRoleWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRoleRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateSpaceRole(ctx context.Context, spaceId SpaceIdParam, body CreateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateSpaceRoleRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteSpaceRole(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteSpaceRoleRequest(c.Server, spaceId, spaceRoleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSpaceRole(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSpaceRoleRequest(c.Server, spaceId, spaceRoleId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceRoleWithBody(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRoleRequestWithBody(c.Server, spaceId, spaceRoleId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSpaceRole(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, body UpdateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateSpaceRoleRequest(c.Server, spaceId, spaceRoleId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListStories(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListStoriesRequest(c.Server, spaceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStoryWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStoryRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateStory(ctx context.Context, spaceId SpaceIdParam, body CreateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateStoryRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteStoryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStoryRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStoryWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStoryRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateStory(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateStoryRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookWithBody(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequestWithBody(c.Server, spaceId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook(ctx context.Context, spaceId SpaceIdParam, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequest(c.Server, spaceId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, spaceId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhookWithBody(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequestWithBody(c.Server, spaceId, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateWebhook(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateWebhookRequest(c.Server, spaceId, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCompareStoryRequest generates requests for CompareStory
func NewCompareStoryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/stories/%s/compare", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPublishStoryRequest generates requests for PublishStory
func NewPublishStoryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/stories/%s/publish", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnpublishStoryRequest generates requests for UnpublishStory
func NewUnpublishStoryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/stories/%s/unpublish", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewVersionsStoryRequest generates requests for VersionsStory
func NewVersionsStoryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/spaces/%s/stories/%s/versions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListSpacesRequest generates requests for ListSpaces
func NewListSpacesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpaceRequest calls the generic CreateSpace builder with application/json body
func NewCreateSpaceRequest(server string, body CreateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpaceRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateSpaceRequestWithBody generates requests for CreateSpace with any type of body
func NewCreateSpaceRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpaceRequest generates requests for DeleteSpace
func NewDeleteSpaceRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceRequest generates requests for GetSpace
func NewGetSpaceRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDuplicateSpaceRequest calls the generic DuplicateSpace builder with application/json body
func NewDuplicateSpaceRequest(server string, spaceId SpaceIdParam, body DuplicateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDuplicateSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewDuplicateSpaceRequestWithBody generates requests for DuplicateSpace with any type of body
func NewDuplicateSpaceRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateSpaceRequest calls the generic UpdateSpace builder with application/json body
func NewUpdateSpaceRequest(server string, spaceId SpaceIdParam, body UpdateSpaceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpaceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewUpdateSpaceRequestWithBody generates requests for UpdateSpace with any type of body
func NewUpdateSpaceRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListAssetFoldersRequest generates requests for ListAssetFolders
func NewListAssetFoldersRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/asset_folders/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAssetFolderRequest calls the generic CreateAssetFolder builder with application/json body
func NewCreateAssetFolderRequest(server string, spaceId SpaceIdParam, body CreateAssetFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAssetFolderRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateAssetFolderRequestWithBody generates requests for CreateAssetFolder with any type of body
func NewCreateAssetFolderRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/asset_folders/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteAssetFolderRequest generates requests for DeleteAssetFolder
func NewDeleteAssetFolderRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/asset_folders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAssetFolderRequest generates requests for GetAssetFolder
func NewGetAssetFolderRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/asset_folders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateAssetFolderRequest calls the generic UpdateAssetFolder builder with application/json body
func NewUpdateAssetFolderRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateAssetFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateAssetFolderRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateAssetFolderRequestWithBody generates requests for UpdateAssetFolder with any type of body
func NewUpdateAssetFolderRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/asset_folders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewBackupSpaceRequest generates requests for BackupSpace
func NewBackupSpaceRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/backups/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListComponentGroupsRequest generates requests for ListComponentGroups
func NewListComponentGroupsRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/component_groups/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComponentGroupRequest calls the generic CreateComponentGroup builder with application/json body
func NewCreateComponentGroupRequest(server string, spaceId SpaceIdParam, body CreateComponentGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateComponentGroupRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateComponentGroupRequestWithBody generates requests for CreateComponentGroup with any type of body
func NewCreateComponentGroupRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/component_groups/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComponentGroupRequest generates requests for DeleteComponentGroup
func NewDeleteComponentGroupRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/component_groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComponentGroupRequest generates requests for GetComponentGroup
func NewGetComponentGroupRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/component_groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateComponentGroupRequest calls the generic UpdateComponentGroup builder with application/json body
func NewUpdateComponentGroupRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateComponentGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateComponentGroupRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateComponentGroupRequestWithBody generates requests for UpdateComponentGroup with any type of body
func NewUpdateComponentGroupRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/component_groups/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListComponentsRequest generates requests for ListComponents
func NewListComponentsRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateComponentRequest calls the generic CreateComponent builder with application/json body
func NewCreateComponentRequest(server string, spaceId SpaceIdParam, body CreateComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateComponentRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateComponentRequestWithBody generates requests for CreateComponent with any type of body
func NewCreateComponentRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteComponentRequest generates requests for DeleteComponent
func NewDeleteComponentRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetComponentRequest generates requests for GetComponent
func NewGetComponentRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateComponentRequest calls the generic UpdateComponent builder with application/json body
func NewUpdateComponentRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateComponentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateComponentRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateComponentRequestWithBody generates requests for UpdateComponent with any type of body
func NewUpdateComponentRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/components/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDatasourceEntriesRequest generates requests for ListDatasourceEntries
func NewListDatasourceEntriesRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasource_entries/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatasourceEntryRequest calls the generic CreateDatasourceEntry builder with application/json body
func NewCreateDatasourceEntryRequest(server string, spaceId SpaceIdParam, body CreateDatasourceEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatasourceEntryRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDatasourceEntryRequestWithBody generates requests for CreateDatasourceEntry with any type of body
func NewCreateDatasourceEntryRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasource_entries/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatasourceEntryRequest generates requests for DeleteDatasourceEntry
func NewDeleteDatasourceEntryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasource_entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatasourceEntryRequest generates requests for GetDatasourceEntry
func NewGetDatasourceEntryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasource_entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatasourceEntryRequest calls the generic UpdateDatasourceEntry builder with application/json body
func NewUpdateDatasourceEntryRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatasourceEntryRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateDatasourceEntryRequestWithBody generates requests for UpdateDatasourceEntry with any type of body
func NewUpdateDatasourceEntryRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasource_entries/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListDatasourcesRequest generates requests for ListDatasources
func NewListDatasourcesRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasources/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDatasourceRequest calls the generic CreateDatasource builder with application/json body
func NewCreateDatasourceRequest(server string, spaceId SpaceIdParam, body CreateDatasourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDatasourceRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateDatasourceRequestWithBody generates requests for CreateDatasource with any type of body
func NewCreateDatasourceRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasources/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDatasourceRequest generates requests for DeleteDatasource
func NewDeleteDatasourceRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDatasourceRequest generates requests for GetDatasource
func NewGetDatasourceRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateDatasourceRequest calls the generic UpdateDatasource builder with application/json body
func NewUpdateDatasourceRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateDatasourceRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateDatasourceRequestWithBody generates requests for UpdateDatasource with any type of body
func NewUpdateDatasourceRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/datasources/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMultipleSpaceRolesRequest generates requests for GetMultipleSpaceRoles
func NewGetMultipleSpaceRolesRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/space_roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateSpaceRoleRequest calls the generic CreateSpaceRole builder with application/json body
func NewCreateSpaceRoleRequest(server string, spaceId SpaceIdParam, body CreateSpaceRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateSpaceRoleRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateSpaceRoleRequestWithBody generates requests for CreateSpaceRole with any type of body
func NewCreateSpaceRoleRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/space_roles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteSpaceRoleRequest generates requests for DeleteSpaceRole
func NewDeleteSpaceRoleRequest(server string, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "space_role_id", runtime.ParamLocationPath, spaceRoleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/space_roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSpaceRoleRequest generates requests for GetSpaceRole
func NewGetSpaceRoleRequest(server string, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "space_role_id", runtime.ParamLocationPath, spaceRoleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/space_roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateSpaceRoleRequest calls the generic UpdateSpaceRole builder with application/json body
func NewUpdateSpaceRoleRequest(server string, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, body UpdateSpaceRoleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateSpaceRoleRequestWithBody(server, spaceId, spaceRoleId, "application/json", bodyReader)
}

// NewUpdateSpaceRoleRequestWithBody generates requests for UpdateSpaceRole with any type of body
func NewUpdateSpaceRoleRequestWithBody(server string, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "space_role_id", runtime.ParamLocationPath, spaceRoleId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/space_roles/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListStoriesRequest generates requests for ListStories
func NewListStoriesRequest(server string, spaceId SpaceIdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/stories/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateStoryRequest calls the generic CreateStory builder with application/json body
func NewCreateStoryRequest(server string, spaceId SpaceIdParam, body CreateStoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateStoryRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateStoryRequestWithBody generates requests for CreateStory with any type of body
func NewCreateStoryRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/stories/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteStoryRequest generates requests for DeleteStory
func NewDeleteStoryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/stories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStoryRequest generates requests for GetStory
func NewGetStoryRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/stories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateStoryRequest calls the generic UpdateStory builder with application/json body
func NewUpdateStoryRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateStoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateStoryRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateStoryRequestWithBody generates requests for UpdateStory with any type of body
func NewUpdateStoryRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/stories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWebhookRequest calls the generic CreateWebhook builder with application/json body
func NewCreateWebhookRequest(server string, spaceId SpaceIdParam, body CreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookRequestWithBody(server, spaceId, "application/json", bodyReader)
}

// NewCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func NewCreateWebhookRequestWithBody(server string, spaceId SpaceIdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/webhook_endpoints/", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/webhook_endpoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, spaceId SpaceIdParam, id IdParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/webhook_endpoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateWebhookRequest calls the generic UpdateWebhook builder with application/json body
func NewUpdateWebhookRequest(server string, spaceId SpaceIdParam, id IdParam, body UpdateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateWebhookRequestWithBody(server, spaceId, id, "application/json", bodyReader)
}

// NewUpdateWebhookRequestWithBody generates requests for UpdateWebhook with any type of body
func NewUpdateWebhookRequestWithBody(server string, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "space_id", runtime.ParamLocationPath, spaceId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/spaces/%s/webhook_endpoints/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CompareStoryWithResponse request
	CompareStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*CompareStoryResponse, error)

	// PublishStoryWithResponse request
	PublishStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*PublishStoryResponse, error)

	// UnpublishStoryWithResponse request
	UnpublishStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*UnpublishStoryResponse, error)

	// VersionsStoryWithResponse request
	VersionsStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*VersionsStoryResponse, error)

	// ListSpacesWithResponse request
	ListSpacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error)

	// CreateSpaceWithBodyWithResponse request with any body
	CreateSpaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	CreateSpaceWithResponse(ctx context.Context, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error)

	// DeleteSpaceWithResponse request
	DeleteSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error)

	// GetSpaceWithResponse request
	GetSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*GetSpaceResponse, error)

	// DuplicateSpaceWithBodyWithResponse request with any body
	DuplicateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuplicateSpaceResponse, error)

	DuplicateSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, body DuplicateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*DuplicateSpaceResponse, error)

	// UpdateSpaceWithBodyWithResponse request with any body
	UpdateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	UpdateSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error)

	// ListAssetFoldersWithResponse request
	ListAssetFoldersWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListAssetFoldersResponse, error)

	// CreateAssetFolderWithBodyWithResponse request with any body
	CreateAssetFolderWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetFolderResponse, error)

	CreateAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetFolderResponse, error)

	// DeleteAssetFolderWithResponse request
	DeleteAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteAssetFolderResponse, error)

	// GetAssetFolderWithResponse request
	GetAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetAssetFolderResponse, error)

	// UpdateAssetFolderWithBodyWithResponse request with any body
	UpdateAssetFolderWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetFolderResponse, error)

	UpdateAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetFolderResponse, error)

	// BackupSpaceWithResponse request
	BackupSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*BackupSpaceResponse, error)

	// ListComponentGroupsWithResponse request
	ListComponentGroupsWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListComponentGroupsResponse, error)

	// CreateComponentGroupWithBodyWithResponse request with any body
	CreateComponentGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComponentGroupResponse, error)

	CreateComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComponentGroupResponse, error)

	// DeleteComponentGroupWithResponse request
	DeleteComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteComponentGroupResponse, error)

	// GetComponentGroupWithResponse request
	GetComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetComponentGroupResponse, error)

	// UpdateComponentGroupWithBodyWithResponse request with any body
	UpdateComponentGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentGroupResponse, error)

	UpdateComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentGroupResponse, error)

	// ListComponentsWithResponse request
	ListComponentsWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListComponentsResponse, error)

	// CreateComponentWithBodyWithResponse request with any body
	CreateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error)

	CreateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error)

	// DeleteComponentWithResponse request
	DeleteComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteComponentResponse, error)

	// GetComponentWithResponse request
	GetComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetComponentResponse, error)

	// UpdateComponentWithBodyWithResponse request with any body
	UpdateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error)

	UpdateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error)

	// ListDatasourceEntriesWithResponse request
	ListDatasourceEntriesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListDatasourceEntriesResponse, error)

	// CreateDatasourceEntryWithBodyWithResponse request with any body
	CreateDatasourceEntryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasourceEntryResponse, error)

	CreateDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasourceEntryResponse, error)

	// DeleteDatasourceEntryWithResponse request
	DeleteDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteDatasourceEntryResponse, error)

	// GetDatasourceEntryWithResponse request
	GetDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetDatasourceEntryResponse, error)

	// UpdateDatasourceEntryWithBodyWithResponse request with any body
	UpdateDatasourceEntryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasourceEntryResponse, error)

	UpdateDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasourceEntryResponse, error)

	// ListDatasourcesWithResponse request
	ListDatasourcesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListDatasourcesResponse, error)

	// CreateDatasourceWithBodyWithResponse request with any body
	CreateDatasourceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error)

	CreateDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error)

	// DeleteDatasourceWithResponse request
	DeleteDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteDatasourceResponse, error)

	// GetDatasourceWithResponse request
	GetDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetDatasourceResponse, error)

	// UpdateDatasourceWithBodyWithResponse request with any body
	UpdateDatasourceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasourceResponse, error)

	UpdateDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasourceResponse, error)

	// GetMultipleSpaceRolesWithResponse request
	GetMultipleSpaceRolesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*GetMultipleSpaceRolesResponse, error)

	// CreateSpaceRoleWithBodyWithResponse request with any body
	CreateSpaceRoleWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceRoleResponse, error)

	CreateSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceRoleResponse, error)

	// DeleteSpaceRoleWithResponse request
	DeleteSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*DeleteSpaceRoleResponse, error)

	// GetSpaceRoleWithResponse request
	GetSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*GetSpaceRoleResponse, error)

	// UpdateSpaceRoleWithBodyWithResponse request with any body
	UpdateSpaceRoleWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceRoleResponse, error)

	UpdateSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, body UpdateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceRoleResponse, error)

	// ListStoriesWithResponse request
	ListStoriesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListStoriesResponse, error)

	// CreateStoryWithBodyWithResponse request with any body
	CreateStoryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStoryResponse, error)

	CreateStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStoryResponse, error)

	// DeleteStoryWithResponse request
	DeleteStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteStoryResponse, error)

	// GetStoryWithResponse request
	GetStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetStoryResponse, error)

	// UpdateStoryWithBodyWithResponse request with any body
	UpdateStoryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStoryResponse, error)

	UpdateStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStoryResponse, error)

	// CreateWebhookWithBodyWithResponse request with any body
	CreateWebhookWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	CreateWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// UpdateWebhookWithBodyWithResponse request with any body
	UpdateWebhookWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)

	UpdateWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error)
}

type CompareStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[][]string
}

// Status returns HTTPResponse.Status
func (r CompareStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CompareStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PublishStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
		Story *Story `json:"story,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r PublishStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PublishStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnpublishStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
		Story *Story `json:"story,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UnpublishStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnpublishStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VersionsStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Versions *[]Version `json:"versions,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r VersionsStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VersionsStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSpacesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Spaces *[]Space `json:"spaces,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListSpacesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSpacesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DuplicateSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DuplicateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DuplicateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListAssetFoldersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		AssetFolders *[]AssetFolder `json:"asset_folders,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListAssetFoldersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListAssetFoldersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAssetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
		AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAssetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAssetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAssetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
		AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteAssetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAssetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAssetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
		AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAssetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAssetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateAssetFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
		AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateAssetFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateAssetFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BackupSpaceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Space *Space `json:"space,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r BackupSpaceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BackupSpaceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListComponentGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ComponentGroups *[]ComponentGroup `json:"component_groups,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListComponentGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListComponentGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComponentGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
		ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateComponentGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComponentGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComponentGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
		ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteComponentGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComponentGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComponentGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
		ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComponentGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComponentGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateComponentGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
		ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateComponentGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComponentGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListComponentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Components *[]Component `json:"components,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListComponentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListComponentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateComponentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
		Component *Component `json:"component,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateComponentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateComponentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatasourceEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		DatasourceEntries *[]DatasourceEntry `json:"datasource_entries,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDatasourceEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatasourceEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatasourceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
		DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateDatasourceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatasourceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatasourceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
		DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDatasourceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatasourceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatasourceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
		DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDatasourceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatasourceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatasourceEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
		DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateDatasourceEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatasourceEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListDatasourcesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Datasources *[]Datasource `json:"datasources,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListDatasourcesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDatasourcesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDatasourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Datasource
}

// Status returns HTTPResponse.Status
func (r CreateDatasourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDatasourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDatasourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Datasource A datasource is a collection of datasource entries with a specific name and slug. Each datasource entry is a collection of key-value pairs (KVP), so called datasource entries. Those key-value pairs can be used for a single choice, multiple choice options and as well directly through our API to use them for multi-language labels, categories, or anything similar.
		Datasource *Datasource `json:"datasource,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteDatasourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDatasourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDatasourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Datasource A datasource is a collection of datasource entries with a specific name and slug. Each datasource entry is a collection of key-value pairs (KVP), so called datasource entries. Those key-value pairs can be used for a single choice, multiple choice options and as well directly through our API to use them for multi-language labels, categories, or anything similar.
		Datasource *Datasource `json:"datasource,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetDatasourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDatasourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateDatasourceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Datasource A datasource is a collection of datasource entries with a specific name and slug. Each datasource entry is a collection of key-value pairs (KVP), so called datasource entries. Those key-value pairs can be used for a single choice, multiple choice options and as well directly through our API to use them for multi-language labels, categories, or anything similar.
		Datasource *Datasource `json:"datasource,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateDatasourceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateDatasourceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMultipleSpaceRolesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		SpaceRole *SpaceRole `json:"space_role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMultipleSpaceRolesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMultipleSpaceRolesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateSpaceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		SpaceRole *SpaceRole `json:"space_role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateSpaceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateSpaceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteSpaceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SpaceRole *SpaceRole `json:"space_role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteSpaceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteSpaceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSpaceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SpaceRole *SpaceRole `json:"space_role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetSpaceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSpaceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateSpaceRoleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SpaceRole *SpaceRole `json:"space_role,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateSpaceRoleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateSpaceRoleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListStoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Stories *[]Story `json:"stories,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListStoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListStoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
		Story *Story `json:"story,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
		Story *Story `json:"story,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
		Story *Story `json:"story,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateStoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
		Story *Story `json:"story,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateStoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateStoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		WebhookEndpoint Webhook `json:"webhook_endpoint"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		WebhookEndpoint Webhook `json:"webhook_endpoint"`
	}
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WebhookEndpoint Webhook `json:"webhook_endpoint"`
	}
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		WebhookEndpoint Webhook `json:"webhook_endpoint"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CompareStoryWithResponse request returning *CompareStoryResponse
func (c *ClientWithResponses) CompareStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*CompareStoryResponse, error) {
	rsp, err := c.CompareStory(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCompareStoryResponse(rsp)
}

// PublishStoryWithResponse request returning *PublishStoryResponse
func (c *ClientWithResponses) PublishStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*PublishStoryResponse, error) {
	rsp, err := c.PublishStory(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePublishStoryResponse(rsp)
}

// UnpublishStoryWithResponse request returning *UnpublishStoryResponse
func (c *ClientWithResponses) UnpublishStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*UnpublishStoryResponse, error) {
	rsp, err := c.UnpublishStory(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnpublishStoryResponse(rsp)
}

// VersionsStoryWithResponse request returning *VersionsStoryResponse
func (c *ClientWithResponses) VersionsStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*VersionsStoryResponse, error) {
	rsp, err := c.VersionsStory(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVersionsStoryResponse(rsp)
}

// ListSpacesWithResponse request returning *ListSpacesResponse
func (c *ClientWithResponses) ListSpacesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListSpacesResponse, error) {
	rsp, err := c.ListSpaces(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSpacesResponse(rsp)
}

// CreateSpaceWithBodyWithResponse request with arbitrary body returning *CreateSpaceResponse
func (c *ClientWithResponses) CreateSpaceWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpaceWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

func (c *ClientWithResponses) CreateSpaceWithResponse(ctx context.Context, body CreateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceResponse, error) {
	rsp, err := c.CreateSpace(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceResponse(rsp)
}

// DeleteSpaceWithResponse request returning *DeleteSpaceResponse
func (c *ClientWithResponses) DeleteSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*DeleteSpaceResponse, error) {
	rsp, err := c.DeleteSpace(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceResponse(rsp)
}

// GetSpaceWithResponse request returning *GetSpaceResponse
func (c *ClientWithResponses) GetSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*GetSpaceResponse, error) {
	rsp, err := c.GetSpace(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceResponse(rsp)
}

// DuplicateSpaceWithBodyWithResponse request with arbitrary body returning *DuplicateSpaceResponse
func (c *ClientWithResponses) DuplicateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DuplicateSpaceResponse, error) {
	rsp, err := c.DuplicateSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuplicateSpaceResponse(rsp)
}

func (c *ClientWithResponses) DuplicateSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, body DuplicateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*DuplicateSpaceResponse, error) {
	rsp, err := c.DuplicateSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDuplicateSpaceResponse(rsp)
}

// UpdateSpaceWithBodyWithResponse request with arbitrary body returning *UpdateSpaceResponse
func (c *ClientWithResponses) UpdateSpaceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpaceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, body UpdateSpaceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceResponse, error) {
	rsp, err := c.UpdateSpace(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceResponse(rsp)
}

// ListAssetFoldersWithResponse request returning *ListAssetFoldersResponse
func (c *ClientWithResponses) ListAssetFoldersWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListAssetFoldersResponse, error) {
	rsp, err := c.ListAssetFolders(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListAssetFoldersResponse(rsp)
}

// CreateAssetFolderWithBodyWithResponse request with arbitrary body returning *CreateAssetFolderResponse
func (c *ClientWithResponses) CreateAssetFolderWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAssetFolderResponse, error) {
	rsp, err := c.CreateAssetFolderWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetFolderResponse(rsp)
}

func (c *ClientWithResponses) CreateAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAssetFolderResponse, error) {
	rsp, err := c.CreateAssetFolder(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAssetFolderResponse(rsp)
}

// DeleteAssetFolderWithResponse request returning *DeleteAssetFolderResponse
func (c *ClientWithResponses) DeleteAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteAssetFolderResponse, error) {
	rsp, err := c.DeleteAssetFolder(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAssetFolderResponse(rsp)
}

// GetAssetFolderWithResponse request returning *GetAssetFolderResponse
func (c *ClientWithResponses) GetAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetAssetFolderResponse, error) {
	rsp, err := c.GetAssetFolder(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAssetFolderResponse(rsp)
}

// UpdateAssetFolderWithBodyWithResponse request with arbitrary body returning *UpdateAssetFolderResponse
func (c *ClientWithResponses) UpdateAssetFolderWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateAssetFolderResponse, error) {
	rsp, err := c.UpdateAssetFolderWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateAssetFolderWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateAssetFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateAssetFolderResponse, error) {
	rsp, err := c.UpdateAssetFolder(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateAssetFolderResponse(rsp)
}

// BackupSpaceWithResponse request returning *BackupSpaceResponse
func (c *ClientWithResponses) BackupSpaceWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*BackupSpaceResponse, error) {
	rsp, err := c.BackupSpace(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBackupSpaceResponse(rsp)
}

// ListComponentGroupsWithResponse request returning *ListComponentGroupsResponse
func (c *ClientWithResponses) ListComponentGroupsWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListComponentGroupsResponse, error) {
	rsp, err := c.ListComponentGroups(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListComponentGroupsResponse(rsp)
}

// CreateComponentGroupWithBodyWithResponse request with arbitrary body returning *CreateComponentGroupResponse
func (c *ClientWithResponses) CreateComponentGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComponentGroupResponse, error) {
	rsp, err := c.CreateComponentGroupWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComponentGroupResponse(rsp)
}

func (c *ClientWithResponses) CreateComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComponentGroupResponse, error) {
	rsp, err := c.CreateComponentGroup(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComponentGroupResponse(rsp)
}

// DeleteComponentGroupWithResponse request returning *DeleteComponentGroupResponse
func (c *ClientWithResponses) DeleteComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteComponentGroupResponse, error) {
	rsp, err := c.DeleteComponentGroup(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComponentGroupResponse(rsp)
}

// GetComponentGroupWithResponse request returning *GetComponentGroupResponse
func (c *ClientWithResponses) GetComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetComponentGroupResponse, error) {
	rsp, err := c.GetComponentGroup(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComponentGroupResponse(rsp)
}

// UpdateComponentGroupWithBodyWithResponse request with arbitrary body returning *UpdateComponentGroupResponse
func (c *ClientWithResponses) UpdateComponentGroupWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentGroupResponse, error) {
	rsp, err := c.UpdateComponentGroupWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentGroupResponse(rsp)
}

func (c *ClientWithResponses) UpdateComponentGroupWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentGroupResponse, error) {
	rsp, err := c.UpdateComponentGroup(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentGroupResponse(rsp)
}

// ListComponentsWithResponse request returning *ListComponentsResponse
func (c *ClientWithResponses) ListComponentsWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListComponentsResponse, error) {
	rsp, err := c.ListComponents(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListComponentsResponse(rsp)
}

// CreateComponentWithBodyWithResponse request with arbitrary body returning *CreateComponentResponse
func (c *ClientWithResponses) CreateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error) {
	rsp, err := c.CreateComponentWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComponentResponse(rsp)
}

func (c *ClientWithResponses) CreateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateComponentResponse, error) {
	rsp, err := c.CreateComponent(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateComponentResponse(rsp)
}

// DeleteComponentWithResponse request returning *DeleteComponentResponse
func (c *ClientWithResponses) DeleteComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteComponentResponse, error) {
	rsp, err := c.DeleteComponent(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteComponentResponse(rsp)
}

// GetComponentWithResponse request returning *GetComponentResponse
func (c *ClientWithResponses) GetComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetComponentResponse, error) {
	rsp, err := c.GetComponent(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetComponentResponse(rsp)
}

// UpdateComponentWithBodyWithResponse request with arbitrary body returning *UpdateComponentResponse
func (c *ClientWithResponses) UpdateComponentWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error) {
	rsp, err := c.UpdateComponentWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentResponse(rsp)
}

func (c *ClientWithResponses) UpdateComponentWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateComponentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateComponentResponse, error) {
	rsp, err := c.UpdateComponent(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateComponentResponse(rsp)
}

// ListDatasourceEntriesWithResponse request returning *ListDatasourceEntriesResponse
func (c *ClientWithResponses) ListDatasourceEntriesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListDatasourceEntriesResponse, error) {
	rsp, err := c.ListDatasourceEntries(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatasourceEntriesResponse(rsp)
}

// CreateDatasourceEntryWithBodyWithResponse request with arbitrary body returning *CreateDatasourceEntryResponse
func (c *ClientWithResponses) CreateDatasourceEntryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasourceEntryResponse, error) {
	rsp, err := c.CreateDatasourceEntryWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatasourceEntryResponse(rsp)
}

func (c *ClientWithResponses) CreateDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasourceEntryResponse, error) {
	rsp, err := c.CreateDatasourceEntry(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatasourceEntryResponse(rsp)
}

// DeleteDatasourceEntryWithResponse request returning *DeleteDatasourceEntryResponse
func (c *ClientWithResponses) DeleteDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteDatasourceEntryResponse, error) {
	rsp, err := c.DeleteDatasourceEntry(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatasourceEntryResponse(rsp)
}

// GetDatasourceEntryWithResponse request returning *GetDatasourceEntryResponse
func (c *ClientWithResponses) GetDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetDatasourceEntryResponse, error) {
	rsp, err := c.GetDatasourceEntry(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatasourceEntryResponse(rsp)
}

// UpdateDatasourceEntryWithBodyWithResponse request with arbitrary body returning *UpdateDatasourceEntryResponse
func (c *ClientWithResponses) UpdateDatasourceEntryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasourceEntryResponse, error) {
	rsp, err := c.UpdateDatasourceEntryWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatasourceEntryResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatasourceEntryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasourceEntryResponse, error) {
	rsp, err := c.UpdateDatasourceEntry(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatasourceEntryResponse(rsp)
}

// ListDatasourcesWithResponse request returning *ListDatasourcesResponse
func (c *ClientWithResponses) ListDatasourcesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListDatasourcesResponse, error) {
	rsp, err := c.ListDatasources(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDatasourcesResponse(rsp)
}

// CreateDatasourceWithBodyWithResponse request with arbitrary body returning *CreateDatasourceResponse
func (c *ClientWithResponses) CreateDatasourceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error) {
	rsp, err := c.CreateDatasourceWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatasourceResponse(rsp)
}

func (c *ClientWithResponses) CreateDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDatasourceResponse, error) {
	rsp, err := c.CreateDatasource(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDatasourceResponse(rsp)
}

// DeleteDatasourceWithResponse request returning *DeleteDatasourceResponse
func (c *ClientWithResponses) DeleteDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteDatasourceResponse, error) {
	rsp, err := c.DeleteDatasource(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDatasourceResponse(rsp)
}

// GetDatasourceWithResponse request returning *GetDatasourceResponse
func (c *ClientWithResponses) GetDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetDatasourceResponse, error) {
	rsp, err := c.GetDatasource(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDatasourceResponse(rsp)
}

// UpdateDatasourceWithBodyWithResponse request with arbitrary body returning *UpdateDatasourceResponse
func (c *ClientWithResponses) UpdateDatasourceWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateDatasourceResponse, error) {
	rsp, err := c.UpdateDatasourceWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatasourceResponse(rsp)
}

func (c *ClientWithResponses) UpdateDatasourceWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateDatasourceJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateDatasourceResponse, error) {
	rsp, err := c.UpdateDatasource(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateDatasourceResponse(rsp)
}

// GetMultipleSpaceRolesWithResponse request returning *GetMultipleSpaceRolesResponse
func (c *ClientWithResponses) GetMultipleSpaceRolesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*GetMultipleSpaceRolesResponse, error) {
	rsp, err := c.GetMultipleSpaceRoles(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMultipleSpaceRolesResponse(rsp)
}

// CreateSpaceRoleWithBodyWithResponse request with arbitrary body returning *CreateSpaceRoleResponse
func (c *ClientWithResponses) CreateSpaceRoleWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateSpaceRoleResponse, error) {
	rsp, err := c.CreateSpaceRoleWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceRoleResponse(rsp)
}

func (c *ClientWithResponses) CreateSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateSpaceRoleResponse, error) {
	rsp, err := c.CreateSpaceRole(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateSpaceRoleResponse(rsp)
}

// DeleteSpaceRoleWithResponse request returning *DeleteSpaceRoleResponse
func (c *ClientWithResponses) DeleteSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*DeleteSpaceRoleResponse, error) {
	rsp, err := c.DeleteSpaceRole(ctx, spaceId, spaceRoleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteSpaceRoleResponse(rsp)
}

// GetSpaceRoleWithResponse request returning *GetSpaceRoleResponse
func (c *ClientWithResponses) GetSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, reqEditors ...RequestEditorFn) (*GetSpaceRoleResponse, error) {
	rsp, err := c.GetSpaceRole(ctx, spaceId, spaceRoleId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSpaceRoleResponse(rsp)
}

// UpdateSpaceRoleWithBodyWithResponse request with arbitrary body returning *UpdateSpaceRoleResponse
func (c *ClientWithResponses) UpdateSpaceRoleWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateSpaceRoleResponse, error) {
	rsp, err := c.UpdateSpaceRoleWithBody(ctx, spaceId, spaceRoleId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceRoleResponse(rsp)
}

func (c *ClientWithResponses) UpdateSpaceRoleWithResponse(ctx context.Context, spaceId SpaceIdParam, spaceRoleId SpaceRoleIdParam, body UpdateSpaceRoleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateSpaceRoleResponse, error) {
	rsp, err := c.UpdateSpaceRole(ctx, spaceId, spaceRoleId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateSpaceRoleResponse(rsp)
}

// ListStoriesWithResponse request returning *ListStoriesResponse
func (c *ClientWithResponses) ListStoriesWithResponse(ctx context.Context, spaceId SpaceIdParam, reqEditors ...RequestEditorFn) (*ListStoriesResponse, error) {
	rsp, err := c.ListStories(ctx, spaceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListStoriesResponse(rsp)
}

// CreateStoryWithBodyWithResponse request with arbitrary body returning *CreateStoryResponse
func (c *ClientWithResponses) CreateStoryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateStoryResponse, error) {
	rsp, err := c.CreateStoryWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStoryResponse(rsp)
}

func (c *ClientWithResponses) CreateStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateStoryResponse, error) {
	rsp, err := c.CreateStory(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateStoryResponse(rsp)
}

// DeleteStoryWithResponse request returning *DeleteStoryResponse
func (c *ClientWithResponses) DeleteStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteStoryResponse, error) {
	rsp, err := c.DeleteStory(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteStoryResponse(rsp)
}

// GetStoryWithResponse request returning *GetStoryResponse
func (c *ClientWithResponses) GetStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetStoryResponse, error) {
	rsp, err := c.GetStory(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStoryResponse(rsp)
}

// UpdateStoryWithBodyWithResponse request with arbitrary body returning *UpdateStoryResponse
func (c *ClientWithResponses) UpdateStoryWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateStoryResponse, error) {
	rsp, err := c.UpdateStoryWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateStoryWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateStoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateStoryResponse, error) {
	rsp, err := c.UpdateStory(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateStoryResponse(rsp)
}

// CreateWebhookWithBodyWithResponse request with arbitrary body returning *CreateWebhookResponse
func (c *ClientWithResponses) CreateWebhookWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhookWithBody(ctx, spaceId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhook(ctx, spaceId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, spaceId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// UpdateWebhookWithBodyWithResponse request with arbitrary body returning *UpdateWebhookResponse
func (c *ClientWithResponses) UpdateWebhookWithBodyWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhookWithBody(ctx, spaceId, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateWebhookWithResponse(ctx context.Context, spaceId SpaceIdParam, id IdParam, body UpdateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateWebhookResponse, error) {
	rsp, err := c.UpdateWebhook(ctx, spaceId, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateWebhookResponse(rsp)
}

// ParseCompareStoryResponse parses an HTTP response from a CompareStoryWithResponse call
func ParseCompareStoryResponse(rsp *http.Response) (*CompareStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CompareStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest [][]string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePublishStoryResponse parses an HTTP response from a PublishStoryWithResponse call
func ParsePublishStoryResponse(rsp *http.Response) (*PublishStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PublishStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
			Story *Story `json:"story,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUnpublishStoryResponse parses an HTTP response from a UnpublishStoryWithResponse call
func ParseUnpublishStoryResponse(rsp *http.Response) (*UnpublishStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnpublishStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
			Story *Story `json:"story,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVersionsStoryResponse parses an HTTP response from a VersionsStoryWithResponse call
func ParseVersionsStoryResponse(rsp *http.Response) (*VersionsStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VersionsStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Versions *[]Version `json:"versions,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSpacesResponse parses an HTTP response from a ListSpacesWithResponse call
func ParseListSpacesResponse(rsp *http.Response) (*ListSpacesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSpacesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Spaces *[]Space `json:"spaces,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSpaceResponse parses an HTTP response from a CreateSpaceWithResponse call
func ParseCreateSpaceResponse(rsp *http.Response) (*CreateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceResponse parses an HTTP response from a DeleteSpaceWithResponse call
func ParseDeleteSpaceResponse(rsp *http.Response) (*DeleteSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpaceResponse parses an HTTP response from a GetSpaceWithResponse call
func ParseGetSpaceResponse(rsp *http.Response) (*GetSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDuplicateSpaceResponse parses an HTTP response from a DuplicateSpaceWithResponse call
func ParseDuplicateSpaceResponse(rsp *http.Response) (*DuplicateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DuplicateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSpaceResponse parses an HTTP response from a UpdateSpaceWithResponse call
func ParseUpdateSpaceResponse(rsp *http.Response) (*UpdateSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListAssetFoldersResponse parses an HTTP response from a ListAssetFoldersWithResponse call
func ParseListAssetFoldersResponse(rsp *http.Response) (*ListAssetFoldersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListAssetFoldersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			AssetFolders *[]AssetFolder `json:"asset_folders,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAssetFolderResponse parses an HTTP response from a CreateAssetFolderWithResponse call
func ParseCreateAssetFolderResponse(rsp *http.Response) (*CreateAssetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAssetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
			AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteAssetFolderResponse parses an HTTP response from a DeleteAssetFolderWithResponse call
func ParseDeleteAssetFolderResponse(rsp *http.Response) (*DeleteAssetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAssetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
			AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAssetFolderResponse parses an HTTP response from a GetAssetFolderWithResponse call
func ParseGetAssetFolderResponse(rsp *http.Response) (*GetAssetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAssetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
			AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateAssetFolderResponse parses an HTTP response from a UpdateAssetFolderWithResponse call
func ParseUpdateAssetFolderResponse(rsp *http.Response) (*UpdateAssetFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateAssetFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// AssetFolder A asset folder can be used to group components together. Each component can have only one asset folder.
			AssetFolder *AssetFolder `json:"asset_folder,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBackupSpaceResponse parses an HTTP response from a BackupSpaceWithResponse call
func ParseBackupSpaceResponse(rsp *http.Response) (*BackupSpaceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BackupSpaceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Space *Space `json:"space,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListComponentGroupsResponse parses an HTTP response from a ListComponentGroupsWithResponse call
func ParseListComponentGroupsResponse(rsp *http.Response) (*ListComponentGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListComponentGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ComponentGroups *[]ComponentGroup `json:"component_groups,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateComponentGroupResponse parses an HTTP response from a CreateComponentGroupWithResponse call
func ParseCreateComponentGroupResponse(rsp *http.Response) (*CreateComponentGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComponentGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
			ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteComponentGroupResponse parses an HTTP response from a DeleteComponentGroupWithResponse call
func ParseDeleteComponentGroupResponse(rsp *http.Response) (*DeleteComponentGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComponentGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
			ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetComponentGroupResponse parses an HTTP response from a GetComponentGroupWithResponse call
func ParseGetComponentGroupResponse(rsp *http.Response) (*GetComponentGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComponentGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
			ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateComponentGroupResponse parses an HTTP response from a UpdateComponentGroupWithResponse call
func ParseUpdateComponentGroupResponse(rsp *http.Response) (*UpdateComponentGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateComponentGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// ComponentGroup A component group can be used to group components together. Each component can have only one component group.
			ComponentGroup *ComponentGroup `json:"component_group,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListComponentsResponse parses an HTTP response from a ListComponentsWithResponse call
func ParseListComponentsResponse(rsp *http.Response) (*ListComponentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListComponentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Components *[]Component `json:"components,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateComponentResponse parses an HTTP response from a CreateComponentWithResponse call
func ParseCreateComponentResponse(rsp *http.Response) (*CreateComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteComponentResponse parses an HTTP response from a DeleteComponentWithResponse call
func ParseDeleteComponentResponse(rsp *http.Response) (*DeleteComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetComponentResponse parses an HTTP response from a GetComponentWithResponse call
func ParseGetComponentResponse(rsp *http.Response) (*GetComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateComponentResponse parses an HTTP response from a UpdateComponentWithResponse call
func ParseUpdateComponentResponse(rsp *http.Response) (*UpdateComponentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateComponentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Component A component is a standalone entity that is meaningful in its own right. While components (or bloks) can be nested in each other, semantically they remain equal. Each component is a small piece of your data structure which can be filled with content or nested by your content editor. One component can consist of as many field types as required.
			Component *Component `json:"component,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDatasourceEntriesResponse parses an HTTP response from a ListDatasourceEntriesWithResponse call
func ParseListDatasourceEntriesResponse(rsp *http.Response) (*ListDatasourceEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatasourceEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			DatasourceEntries *[]DatasourceEntry `json:"datasource_entries,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDatasourceEntryResponse parses an HTTP response from a CreateDatasourceEntryWithResponse call
func ParseCreateDatasourceEntryResponse(rsp *http.Response) (*CreateDatasourceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatasourceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
			DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteDatasourceEntryResponse parses an HTTP response from a DeleteDatasourceEntryWithResponse call
func ParseDeleteDatasourceEntryResponse(rsp *http.Response) (*DeleteDatasourceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatasourceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
			DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatasourceEntryResponse parses an HTTP response from a GetDatasourceEntryWithResponse call
func ParseGetDatasourceEntryResponse(rsp *http.Response) (*GetDatasourceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatasourceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
			DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDatasourceEntryResponse parses an HTTP response from a UpdateDatasourceEntryWithResponse call
func ParseUpdateDatasourceEntryResponse(rsp *http.Response) (*UpdateDatasourceEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatasourceEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// DatasourceEntry The actual KEY/VALUE pair object a datasource consists of. One specific datasource entry is a set of two linked data items: a key, which is a unique identifier for the item of data scoped in the data source, and the value, which is the data that is identified.
			DatasourceEntry *DatasourceEntry `json:"datasource_entry,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListDatasourcesResponse parses an HTTP response from a ListDatasourcesWithResponse call
func ParseListDatasourcesResponse(rsp *http.Response) (*ListDatasourcesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDatasourcesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Datasources *[]Datasource `json:"datasources,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDatasourceResponse parses an HTTP response from a CreateDatasourceWithResponse call
func ParseCreateDatasourceResponse(rsp *http.Response) (*CreateDatasourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDatasourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Datasource
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteDatasourceResponse parses an HTTP response from a DeleteDatasourceWithResponse call
func ParseDeleteDatasourceResponse(rsp *http.Response) (*DeleteDatasourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDatasourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Datasource A datasource is a collection of datasource entries with a specific name and slug. Each datasource entry is a collection of key-value pairs (KVP), so called datasource entries. Those key-value pairs can be used for a single choice, multiple choice options and as well directly through our API to use them for multi-language labels, categories, or anything similar.
			Datasource *Datasource `json:"datasource,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetDatasourceResponse parses an HTTP response from a GetDatasourceWithResponse call
func ParseGetDatasourceResponse(rsp *http.Response) (*GetDatasourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDatasourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Datasource A datasource is a collection of datasource entries with a specific name and slug. Each datasource entry is a collection of key-value pairs (KVP), so called datasource entries. Those key-value pairs can be used for a single choice, multiple choice options and as well directly through our API to use them for multi-language labels, categories, or anything similar.
			Datasource *Datasource `json:"datasource,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateDatasourceResponse parses an HTTP response from a UpdateDatasourceWithResponse call
func ParseUpdateDatasourceResponse(rsp *http.Response) (*UpdateDatasourceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateDatasourceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Datasource A datasource is a collection of datasource entries with a specific name and slug. Each datasource entry is a collection of key-value pairs (KVP), so called datasource entries. Those key-value pairs can be used for a single choice, multiple choice options and as well directly through our API to use them for multi-language labels, categories, or anything similar.
			Datasource *Datasource `json:"datasource,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMultipleSpaceRolesResponse parses an HTTP response from a GetMultipleSpaceRolesWithResponse call
func ParseGetMultipleSpaceRolesResponse(rsp *http.Response) (*GetMultipleSpaceRolesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMultipleSpaceRolesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			SpaceRole *SpaceRole `json:"space_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateSpaceRoleResponse parses an HTTP response from a CreateSpaceRoleWithResponse call
func ParseCreateSpaceRoleResponse(rsp *http.Response) (*CreateSpaceRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateSpaceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			SpaceRole *SpaceRole `json:"space_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteSpaceRoleResponse parses an HTTP response from a DeleteSpaceRoleWithResponse call
func ParseDeleteSpaceRoleResponse(rsp *http.Response) (*DeleteSpaceRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteSpaceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SpaceRole *SpaceRole `json:"space_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetSpaceRoleResponse parses an HTTP response from a GetSpaceRoleWithResponse call
func ParseGetSpaceRoleResponse(rsp *http.Response) (*GetSpaceRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSpaceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SpaceRole *SpaceRole `json:"space_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateSpaceRoleResponse parses an HTTP response from a UpdateSpaceRoleWithResponse call
func ParseUpdateSpaceRoleResponse(rsp *http.Response) (*UpdateSpaceRoleResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateSpaceRoleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SpaceRole *SpaceRole `json:"space_role,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListStoriesResponse parses an HTTP response from a ListStoriesWithResponse call
func ParseListStoriesResponse(rsp *http.Response) (*ListStoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListStoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Stories *[]Story `json:"stories,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateStoryResponse parses an HTTP response from a CreateStoryWithResponse call
func ParseCreateStoryResponse(rsp *http.Response) (*CreateStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
			Story *Story `json:"story,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteStoryResponse parses an HTTP response from a DeleteStoryWithResponse call
func ParseDeleteStoryResponse(rsp *http.Response) (*DeleteStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
			Story *Story `json:"story,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStoryResponse parses an HTTP response from a GetStoryWithResponse call
func ParseGetStoryResponse(rsp *http.Response) (*GetStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
			Story *Story `json:"story,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateStoryResponse parses an HTTP response from a UpdateStoryWithResponse call
func ParseUpdateStoryResponse(rsp *http.Response) (*UpdateStoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateStoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// Story This is an object representing your content entry. One Story object can be of a specific type, so called content types and is able to contain components. You define the fields and nestability of your content types to achieve your content structure. You can use this object to build up your entities when migrating or importing content. You can set alternate versions of a story with Management API using the group_id of the story.
			Story *Story `json:"story,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateWebhookResponse parses an HTTP response from a CreateWebhookWithResponse call
func ParseCreateWebhookResponse(rsp *http.Response) (*CreateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			WebhookEndpoint Webhook `json:"webhook_endpoint"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			WebhookEndpoint Webhook `json:"webhook_endpoint"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WebhookEndpoint Webhook `json:"webhook_endpoint"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateWebhookResponse parses an HTTP response from a UpdateWebhookWithResponse call
func ParseUpdateWebhookResponse(rsp *http.Response) (*UpdateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			WebhookEndpoint Webhook `json:"webhook_endpoint"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
